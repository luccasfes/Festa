<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <link rel="icon" type="image/x-icon" href="assets/favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1a237e">
    <title>FlowLink</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>

    <link rel="stylesheet" href="style.css">
</head>

<body class="non-admin">
    <div id="particles"></div>
    <div class="container">
        <header class="app-header">
            <div class="header-controls-left">
                <button class="btn small" id="adminUnlockBtn" onclick="openAdminUnlockModal()">
                    <i class="fas fa-lock"></i>
                    <span id="adminStatusText">Admin</span>
                    <span id="adminNameDisplay" style="margin-left: 5px; display: none;"></span>
                </button>

                <button class="btn small" id="panelBtn" onclick="FuncaoParaAbrirPainel()">
                    <i class="fas fa-cog"></i> <span>Painel</span>
                </button>
            </div>
            <h1><i class="fas fa-music"></i> FlowLink<i class="fas fa-headphones"></i></h1>
            <div class="room-details">
                <span id="roomNameDisplay">Carregando sala...</span>
                (Criada por: <span id="roomCreatorDisplay">...</span>)
            </div>
            <div class="presence-indicator">
                <i class="fas fa-users"></i>
                <span id="userCount">0</span> online
            </div>
        </header>

        <main class="main-layout">
            <section class="input-section card">
                <h2><i class="fas fa-plus-circle"></i> Adicionar Vídeo</h2>
                <div class="input-group">
                    <label for="phone"><i class="fas fa-user"></i> Nome:</label>
                    <input type="text" id="phone" placeholder="Quem adicionou?" required>
                </div>
                <div class="input-group">
                    <label for="videoUrl"><i class="fab fa-youtube"></i> URL do Vídeo:</label>
                    <input type="text" id="videoUrl" placeholder="Link do YouTube" required>
                </div>
                <button class="btn primary" onclick="addVideo()" id="addVideoBtn">
                    <span id="addBtnText">Adicionar à Fila</span>
                    <span id="addBtnLoader" class="loading" style="display: none;"></span>
                </button>
                <button class="btn youtube" onclick="openYTSearchModal()">
                    <i class="fab fa-youtube"></i> Buscar no YouTube
                </button>


            </section>


            <section class="video-player-section card">
                <h2><i class="fas fa-play-circle"></i> Vídeo em Execução</h2>
                <div id="player-container">
                    <div id="videoPlayer"></div>

                    <!-- máscara que bloqueia interações com a barra nativa (continua presente) -->
                    <div id="player-mask"></div>

                    <!-- Controles personalizados (play/pause + volume). Visíveis apenas para non-admin -->
                    <div class="player-overlay-controls" aria-hidden="false">
                        <button id="overlayPlayBtn" title="Play/Pause"><i id="overlayPlayIcon"
                                class="fas fa-play"></i></button>
                        <label for="overlayVolume" style="color:var(--text-secondary);font-size:0.9rem;">Vol</label>
                        <input id="overlayVolume" type="range" min="0" max="100" step="1" value="50"
                            aria-label="Volume">
                        <button id="overlayFullscreenBtn" title="Tela cheia"><i class="fas fa-expand"></i></button>
                    </div>

                </div>


                <div id="currentVideoInfo">
                    <h3>Escolha de: <span id="currentUser">Nenhum vídeo em execução</span></h3>
                    <p class="current-url" id="currentVideoUrl">Nenhuma URL disponível</p>
                </div>
                <button class="btn primary skip-video-button" onclick="handleSkipOrVote()" id="skipVoteBtn">
                    <i class="fas fa-forward"></i>
                    <span id="skipVoteBtnText">Votar para Pular</span>
                    <span id="voteCounterWrapper">
                        (<span id="voteCount">0</span>/<span id="votesNeeded">0</span>)
                    </span>
                    <span id="skipVoteBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </section>

            <section class="queue-section card">
                <h2>
                    <i class="fas fa-list-ol"></i> Fila de Música
                    <button class="btn danger clear-queue-button" onclick="handleClearQueue()">
                        <i class="fas fa-trash-alt"></i> Limpar Fila
                    </button>
                    <button class="btn bulk-remove-button" onclick="removeSelectedVideos()" id="bulkRemoveBtn"
                        style="display: none;">
                        <i class="fas fa-eraser"></i> Remover Selecionados
                    </button>

                    <button id="btn-auto-sugestao" class="btn-sugestao" onclick="openSugestaoModal()">
  <i class="fas fa-magic"></i> Sugerir Música
</button>
                </h2>
                <ul id="videoList" class="video-queue-list"></ul>
            </section>
            <section class="chat-section card">
                <h2><i class="fas fa-comments"></i> Chat da Música</h2>
                <button class="btn danger small" onclick="handleClearChat()" id="clearChatBtn" style="display: none;">
                    <i class="fas fa-eraser"></i> Limpar Chat
                </button>
                <div class="chat-users-online">
                    <div class="online-indicator">
                        <div class="online-dot"></div>
                        <span id="onlineCount">1</span> usuário(s) online
                    </div>
                    <div class="user-info">
                        <span id="userNameDisplay">Visitante</span>
                        <button class="btn small secondary" onclick="openEditNameModal()" style="margin-left: 10px;"
                            title="Alterar seu nome">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                </div>

                <div id="chatMessages" class="chat-messages-list">
                    <div class="empty-chat">
                        <i class="fas fa-comment-slash"></i>
                        <p>Nenhuma mensagem ainda. Seja o primeiro a comentar!</p>
                    </div>
                </div>

                <div class="typing-indicator" id="typingIndicator">
                    <span id="typingUser"></span> está digitando<span
                        class="typing-dots"><span>.</span><span>.</span><span>.</span></span>
                </div>

                <div class="chat-actions-bar" id="chatActionsBar" style="display: none;">
                    <div class="chat-reply-context" id="chatReplyContext" style="display: none;">
                        <div class="chat-reply-info">
                            <span class="chat-reply-user">Respondendo a...</span>
                            <span class="chat-reply-text"></span>
                        </div>
                        <button class="chat-reply-cancel" onclick="cancelReply()">&times;</button>
                    </div>
                </div>
                <div class="chat-input-group">
                    <input type="text" id="chatMessageInput" placeholder="Digite sua mensagem..."
                        onkeypress="handleChatInput(event)">
                    <button class="btn primary" onclick="sendChatMessage()" title="Enviar">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                <div class="emoji-picker-container" id="emojiPickerContainer">
            </section>
        </main>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">×</span>
            <h3><i class="fas fa-trash-alt"></i> Limpar Fila</h3>
            <p>Digite seu nome e a senha para limpar a fila.</p>
            <div class="input-group">
                <label for="adminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="adminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="clearPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="clearPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="togglePassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="clearQueue()" id="clearQueueBtn">
                <span id="clearBtnText">Confirmar Limpeza</span>
                <span id="clearBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="removeModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeRemoveModal()">×</span>
            <h3><i class="fas fa-trash"></i> Remover Vídeo</h3>
            <p>Digite seu nome e a senha para remover o vídeo selecionado.</p>
            <div class="input-group">
                <label for="removeAdminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="removeAdminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="removePassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="removePassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleRemovePassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="removeVideo()" id="removeVideoBtn">
                <span id="removeBtnText">Confirmar Remoção</span>
                <span id="removeBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="ytSearchModal" class="modal yt-search-modal">
        <div class="modal-content">

            <div class="modal-header">
                <h3><i class="fab fa-youtube"></i> Buscar Vídeo no YouTube</h3>
                <button class="close-button" onclick="closeYTSearchModal()">&times;</button>
            </div>

            <div class="modal-body">

                <div class="session-info input-group">
                    <label><i class="fas fa-user"></i> Adicionando como: <strong
                            id="currentSessionUser">-</strong></label>
                    <button class="btn small secondary" onclick="changeUserName()">Alterar</button>
                </div>

                <div id="userNameInputGroup" class="input-group">
                    <label for="ytSearchName"><i class="fas fa-user"></i> Seu Nome:</label>
                    <input type="text" id="ytSearchName" placeholder="Quem está adicionando?"
                        onkeypress="handleNameInputKeyPress(event)">
                    <button class="btn small primary" onclick="setSessionUser()">Confirmar</button>
                </div>

                <div class="search-controls">
                    <input type="text" id="ytSearchQuery" placeholder="Digite sua busca"
                        onkeypress="handleYTSearchKeyPress(event)">
                    <button class="btn primary" onclick="searchYouTube()">
                        <i class="fas fa-search"></i> Buscar
                    </button>
                </div>

                <div class="yt-search-results" id="ytSearchResults">
                </div>

            </div>
        </div>
    </div>

     <div id="sugestaoModal" class="modal sugestao-modal">
  <div class="modal-content">
    <span class="close-button" onclick="closeSugestaoModal()">×</span>
    <h3><i class="fas fa-magic"></i> Sugestão Inteligente</h3>
    
    <div class="sugestao-tabs">
      <button class="sugestao-tab active" onclick="switchTab('genero')">
        <i class="fas fa-music"></i> Por Gênero
      </button>
      <button class="sugestao-tab" onclick="switchTab('similar')">
        <i class="fas fa-random"></i> Similares
      </button>
      <button class="sugestao-tab" onclick="switchTab('tendencia')">
        <i class="fas fa-chart-line"></i> Tendências
      </button>
    </div>

    <div id="generoContent" class="tab-content active">
      <div class="generos-container">
        <button class="genero-btn" onclick="selectGenero('sertanejo')" data-genero="sertanejo">
          <i class="fas fa-guitar genero-icon"></i>
          <span>Sertanejo</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('funk')" data-genero="funk">
          <i class="fas fa-fire genero-icon"></i>
          <span>Funk</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('pop')" data-genero="pop">
          <i class="fas fa-star genero-icon"></i>
          <span>Pop</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('rock')" data-genero="rock">
          <i class="fas fa-guitar-electric genero-icon"></i>
          <span>Rock</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('eletronica')" data-genero="eletronica">
          <i class="fas fa-synth genero-icon"></i>
          <span>Eletrônica</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('rap')" data-genero="rap">
          <i class="fas fa-microphone-alt genero-icon"></i>
          <span>Rap/Hip-Hop</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('reggaeton')" data-genero="reggaeton">
          <i class="fas fa-drum genero-icon"></i>
          <span>Reggaeton</span>
        </button>
        <button class="genero-btn" onclick="selectGenero('pagode')" data-genero="pagode">
          <i class="fas fa-drum genero-icon"></i>
          <span>Pagode/Samba</span>
        </button>
      </div>
    </div>

    <div id="similarContent" class="tab-content" style="display: none;">
      <div style="text-align: center; padding: 30px 0;">
        <i class="fas fa-random" style="font-size: 3rem; color: var(--primary-color); margin-bottom: 15px;"></i>
        <p>Vamos sugerir músicas similares à que está tocando agora!</p>
        <p class="text-muted" style="font-size: 0.9rem;">Baseado no artista e estilo atual.</p>
      </div>
    </div>

    <div id="tendenciaContent" class="tab-content" style="display: none;">
      <div style="text-align: center; padding: 30px 0;">
        <i class="fas fa-chart-line" style="font-size: 3rem; color: var(--success-color); margin-bottom: 15px;"></i>
        <p>Vamos sugerir as músicas mais populares no momento!</p>
        <p class="text-muted" style="font-size: 0.9rem;">Baseado nas tendências atuais do YouTube.</p>
      </div>
    </div>

   <div class="autoplay-controls">
  <h4><i class="fas fa-robot"></i> Reprodução Automática</h4>
  
  <div class="autoplay-option">
    <span>Adicionar automaticamente quando a fila estiver acabando</span>
    <label class="switch">
      <input type="checkbox" id="autoAddToggle" onchange="ativarAutoSugestao()">
      <span class="slider"></span>
    </label>
  </div>

  <div class="autoplay-option">
    <span>Quantidade de músicas na fila:</span>
    <div class="autoplay-count">
      <button class="count-btn" onclick="changeAutoCount(-1)">-</button>
      <span class="count-display" id="autoCount">3</span>
      <button class="count-btn" onclick="changeAutoCount(1)">+</button>
    </div>
  </div>
</div>

<div class="sugestao-actions">
  <button class="btn btn-now" onclick="sugerirAgora()">
    <i class="fas fa-plus-circle"></i> Adicionar Agora
  </button>
  <button class="btn btn-auto" onclick="toggleAutoDjBtn()">
    <i class="fas fa-play-circle"></i> Auto (Ligar/Desligar)
  </button>
</div>
</div> 
</div> 
    <div id="notification" class="notification">
        <span id="notificationMessage"></span>
    </div>

    <!-- Proxiam faixa -->
    <div id="nextVideoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeNextVideoModal()">×</span>
            <h3><i class="fas fa-forward"></i> Próximo Vídeo</h3>
            <p>Digite seu nome e a senha de administrador para pular para o próximo vídeo.</p>
            <div class="input-group">
                <label for="nextAdminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="nextAdminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="nextPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="nextPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleNextPassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="playNextVideo()" id="playNextVideoBtn">
                <span id="playNextBtnText">Confirmar Próximo</span>
                <span id="playNextBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="adminUnlockModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAdminUnlockModal()">×</span>
            <h3><i class="fas fa-user-shield"></i> Login de Administrador</h3>
            <p>Digite suas credenciais para entrar no Modo Admin.</p>
            <div class="input-group">
                <label for="adminUnlockName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="adminUnlockName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="adminUnlockPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="adminUnlockPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleAdminUnlockPassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="loginAdminSession()" id="adminUnlockConfirmBtn">
                <span id="adminUnlockConfirmBtnText">Login</span>
                <span id="adminUnlockConfirmBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="bulkRemoveConfirmModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeBulkRemoveConfirmModal()">×</span>
            <h3><i class="fas fa-exclamation-triangle"></i> Confirmar Remoção</h3>
            <p id="bulkRemoveMessage">Tem certeza que deseja remover os vídeos selecionados?</p>

            <div class="modal-buttons">
                <button class="btn secondary" onclick="closeBulkRemoveConfirmModal()">
                    Cancelar
                </button>
                <button class="btn danger" onclick="executeBulkRemove()" id="bulkRemoveConfirmBtn">
                    <span id="bulkRemoveConfirmBtnText">Remover</span>
                    <span id="bulkRemoveConfirmBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </div>
        </div>
    </div>

    <div id="panelModal" class="modal admin-panel-modal">
        <div class="modal-content">
            <span class="close-button" onclick="closePanelModal()">×</span>

            <div class="admin-panel-header">
                <h3><i class="fas fa-user-shield"></i> Painel Admin - FlowLink</h3>
            </div>

            <div class="admin-panel-body">
                <h4 style="display: flex; justify-content: space-between; align-items: center;">
                    <span><i class="fas fa-server"></i> Salas Ativas</span>

                    <div style="display: flex;"> <button class="btn small secondary" onclick="loadAdminPanelRooms()"
                            title="Atualizar lista">
                            <i class="fas fa-sync-alt"></i> Atualizar
                        </button>

                        <button class="btn small danger" onclick="openDeleteAllRoomsModal()"
                            title="Deletar TODAS as salas" style="margin-left: 10px;">
                            <i class="fas fa-exclamation-triangle"></i> Deletar Tudo
                        </button>
                    </div>
                </h4>

                <div id="adminRoomLoader" class="loading-yt" style="display: none; padding: 40px 0;">
                    Carregando salas...
                </div>

                <div id="adminRoomList" class="admin-room-list">
                </div>
            </div>
        </div>
    </div>

    <div id="deleteAllRoomsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeDeleteAllRoomsModal()">×</span>
            <h3><i class="fas fa-exclamation-triangle"></i> Deletar Todas as Salas</h3>
            <p>
                Tem certeza que deseja deletar <strong>TODAS</strong> as salas ativas?
                <br><br>
                Esta ação é <strong>irreversível</strong> e apagará todas as filas e chats de todos os usuários.
            </p>

            <div class="modal-buttons">
                <button class="btn secondary" onclick="closeDeleteAllRoomsModal()">
                    Cancelar
                </button>
                <button class="btn danger" onclick="executeDeleteAllRooms()" id="deleteAllRoomsConfirmBtn">
                    <span id="deleteAllRoomsConfirmBtnText">Sim, Deletar Tudo</span>
                    <span id="deleteAllRoomsConfirmBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </div>
        </div>
    </div>

    <div id="editNameModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeEditNameModal()">×</span>
            <h3><i class="fas fa-edit"></i> Alterar seu Nome</h3>
            <p>Seu nome é usado no chat e para identificar os vídeos que você adiciona.</p>

            <div class="input-group">
                <label for="editNameInput"><i class="fas fa-user"></i> Seu Nome:</label>
                <input type="text" id="editNameInput" placeholder="Como você quer ser chamado?" maxlength="25">
            </div>

            <button class="btn primary" onclick="saveUserName()" id="saveUserNameBtn">
                <span id="saveUserNameBtnText">Salvar Nome</span>
                <span id="saveUserNameBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <!-- //sessão -->
    <script>

        /**
         * ESTA É A VERSÃO CORRIGIDA DA "PORTEIRA"
         * Ela só executa a lógica do player se ele estiver 100% pronto.
         */
        function updatePlayerMode() {
            // Guarda de segurança: Não faz nada se o player não estiver pronto
            if (!isPlayerReady) {
                console.warn('updatePlayerMode: Player ainda não está pronto. Ignorando.');
                return;
            }

            // Se o Admin estiver logado, ele ignora o Modo Solo.
            if (isAdminLoggedIn) {
                console.log('updatePlayerMode: Admin está logado. Modo Solo ignorado.');
                return;
            }

            // --- LÓGICA SIMPLIFICADA ---
            // O player agora nasce com 'controls: 1' (Modo Solo, por causa do Passo 1)

            if (onlineUserCount <= 1) {
                // --- MODO SOLO ---
                // O player já está correto (controls: 1).

                console.log('updatePlayerMode: Modo Solo ATIVADO.');

                if (videoQueue.length === 0) {
                    // Fila vazia: Apenas ajustamos os botões e garantimos que a máscara está desligada.
                    console.log('... fila vazia, apenas ajustando botões.');
                    document.querySelector('.clear-queue-button').style.display = 'inline-block';
                    document.querySelector('.skip-video-button').style.display = 'inline-block';
                    document.getElementById('skipVoteBtnText').textContent = 'Pular (Modo Solo)';
                    document.getElementById('voteCounterWrapper').style.display = 'none';

                    // Garante que o player inicial (controls: 1) esteja visível
                    document.getElementById('player-mask').style.display = 'none';
                    const overlay = document.querySelector('.player-overlay-controls');
                    if (overlay) overlay.style.display = 'none';
                } else {
                    // Fila tem itens: chama a função completa para garantir que 
                    // o player foi recriado (caso ele estivesse vindo do Modo Festa).
                    console.log('... fila com itens, chamando enableSoloPlayerControls.');
                    if (typeof enableSoloPlayerControls === 'function') {
                        enableSoloPlayerControls(); //
                    }
                }

            } else {
                // --- MODO FESTA ---
                // Estamos em grupo, PRECISAMOS bloquear o player.
                // Chamamos a função que recria o player com 'controls: 0'.

                console.log('updatePlayerMode: Modo Festa ATIVADO.');
                if (typeof disableSoloPlayerControls === 'function') {
                    disableSoloPlayerControls(); //
                }
            }
        }
        let currentSessionUser = null;

        function openYTSearchModal() {
            document.getElementById('ytSearchModal').style.display = 'flex';
            document.getElementById('ytSearchQuery').value = '';
            document.getElementById('ytSearchResults').innerHTML = '';

            // Mostra a interface apropriada baseada no estado
            if (currentSessionUser) {
                document.getElementById('currentSessionUser').textContent = currentSessionUser;
                document.getElementById('userNameInputGroup').style.display = 'none';
                document.querySelector('.session-info').style.display = 'flex';
                document.getElementById('ytSearchQuery').focus();
            } else {
                document.getElementById('userNameInputGroup').style.display = 'block';
                document.querySelector('.session-info').style.display = 'none';
                document.getElementById('ytSearchName').focus();
            }
        }

        function openEditNameModal() {
            // Pega o nome atual (da sessão ou do display)
            const currentName = sessionStorage.getItem('ytSessionUser') || '';
            document.getElementById('editNameInput').value = currentName;

            // Abre o modal
            document.getElementById('editNameModal').style.display = 'flex';
            document.getElementById('editNameInput').focus();
        }

        /**
         * Fecha o modal de edição de nome.
         */
        function closeEditNameModal() {
            document.getElementById('editNameModal').style.display = 'none';
        }

        /**
         * Salva o novo nome do usuário na sessão e no Firebase.
         */
        function saveUserName() {
            toggleLoading('saveUserNameBtn', true); // Ativa o loading

            const newName = document.getElementById('editNameInput').value.trim();

            if (!newName) {
                showNotification('Por favor, digite um nome.', 'error');
                toggleLoading('saveUserNameBtn', false); // Desativa o loading
                return;
            }

            // 1. Salva o nome na sessão (variável global e sessionStorage)
            currentSessionUser = newName;
            sessionStorage.setItem('ytSessionUser', newName);

            // 2. Atualiza o display do chat
            document.getElementById('userNameDisplay').textContent = newName;

            // 3. Atualiza o nome na lista de presença do Firebase
            if (myPresenceRef) {
                myPresenceRef.update({ name: newName });
            }

            // 4. (Importante!) Atualiza o nome no modal do YouTube também
            document.getElementById('currentSessionUser').textContent = newName;

            // Simula um pequeno delay para o feedback (opcional)
            setTimeout(() => {
                toggleLoading('saveUserNameBtn', false); // Desativa o loading
                showNotification('Nome atualizado para ' + newName, 'success');
                closeEditNameModal();
            }, 300);
        }

        // Também adicione o 'Enter' para salvar
        document.addEventListener('DOMContentLoaded', () => {
            const editNameInput = document.getElementById('editNameInput');
            if (editNameInput) {
                editNameInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveUserName();
                    }
                });
            }
        });
        function setSessionUser() {
            const userName = document.getElementById('ytSearchName').value.trim();

            if (!userName) {
                showNotification('Por favor, digite seu nome.', 'error');
                return;
            }

            currentSessionUser = userName;
            document.getElementById('currentSessionUser').textContent = userName;
            document.getElementById('userNameInputGroup').style.display = 'none';
            document.getElementById('userNameDisplay').textContent = userName;
            document.querySelector('.session-info').style.display = 'flex';
            document.getElementById('ytSearchQuery').focus();

            // Salva na sessionStorage para persistir entre recarregamentos
            sessionStorage.setItem('ytSessionUser', userName);

            // *** NOVA LINHA: Atualiza o nome na lista de presença ***
            if (myPresenceRef) {
                myPresenceRef.update({ name: userName });
            }
        }

        function handleNameInputKeyPress(event) {
            // Verifica se a tecla pressionada foi 'Enter'
            if (event.key === 'Enter') {
                // Chama a MESMA função do botão "Confirmar"
                setSessionUser();
            }
        }

        function changeUserName() {
            currentSessionUser = null;
            sessionStorage.removeItem('ytSessionUser');
            document.getElementById('ytSearchName').value = '';
            document.getElementById('userNameInputGroup').style.display = 'block';
            document.querySelector('.session-info').style.display = 'none';
            document.getElementById('ytSearchName').focus();
            document.getElementById('userNameDisplay').textContent = 'Visitante';
            // *** NOVA LINHA: Atualiza o nome para "Visitante" ***
            if (myPresenceRef) {
                myPresenceRef.update({ name: 'Visitante' });
            }
        }

        // Ao carregar a página, verifica se há um nome salvo
        window.addEventListener('DOMContentLoaded', function () {
            const savedUser = sessionStorage.getItem('ytSessionUser');
            if (savedUser) {
                currentSessionUser = savedUser;
                document.getElementById('userNameDisplay').textContent = savedUser;
            }
        });
    </script>
    <script>

        // ====================================================================
        // Funções para o modal de busca no YouTube
        

        function closeYTSearchModal() {
            document.getElementById('ytSearchModal').style.display = 'none';
            document.getElementById('ytSearchQuery').value = '';
            document.getElementById('ytSearchResults').innerHTML = '';
        }

        function selectYouTubeVideo(videoUrl, videoTitle) {
            // Verifica se temos um usuário na sessão
            if (!currentSessionUser) {
                showNotification('Por favor, configure seu nome antes de adicionar vídeos.', 'error');
                // Mostra o campo de nome e foca nele
                document.getElementById('userNameInputGroup').style.display = 'block';
                document.querySelector('.session-info').style.display = 'none';
                document.getElementById('ytSearchName').focus();
                return;
            }

            // Preenche os campos no formulário principal automaticamente
            document.getElementById('phone').value = currentSessionUser;
            document.getElementById('videoUrl').value = videoUrl;

            // Não fecha o modal - permite adicionar mais vídeos
            // Mantém o modal aberto para continuar adicionando

            // Adiciona o vídeo à fila
            setTimeout(() => {
                addVideo();

                // Feedback visual que o vídeo foi adicionado
                showNotification(`"${videoTitle}" adicionado por ${currentSessionUser}`, 'success');

                // Rolagem suave para o resultado adicionado
                setTimeout(() => {
                    const videoList = document.getElementById('videoList');
                    if (videoList.lastChild) {
                        videoList.lastChild.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 300);
            }, 100);
        }

        async function searchYouTube() {
            const query = document.getElementById('ytSearchQuery').value.trim();
            if (!query) {
                showNotification('Digite algo para buscar no YouTube', 'error');
                return;
            }

            const resultsContainer = document.getElementById('ytSearchResults');
            resultsContainer.innerHTML = '<div class="loading-yt">Buscando vídeos...</div>';

            try {
                // --- MUDANÇA AQUI: Chamamos nosso próprio servidor ---
                // Não usamos mais a API Key aqui no front
                const response = await fetch(`/api/youtube-search?q=${encodeURIComponent(query)}`);

                if (!response.ok) throw new Error('Erro na comunicação com o servidor');

                const data = await response.json();

                // O formato de resposta do Axios/Proxy é o mesmo, então o resto do código funciona igual
                const videos = data.items.map(item => ({
                    title: item.snippet.title,
                    url: `https://www.youtube.com/watch?v=${item.id.videoId}`,
                    thumbnail: item.snippet.thumbnails.default.url
                }));

                displayYouTubeResults(videos);
            } catch (error) {
                console.error('Erro na busca:', error);
                resultsContainer.innerHTML = '<div class="error-yt">Erro ao buscar vídeos. Tente novamente.</div>';
            }
        }

        function displayYouTubeResults(videos) {
            const resultsContainer = document.getElementById('ytSearchResults');
            resultsContainer.innerHTML = '';

            if (videos.length === 0) {
                resultsContainer.innerHTML = '<div class="empty-yt">Nenhum vídeo encontrado.</div>';
                return;
            }

            videos.forEach(video => {
                const videoElement = document.createElement('div');
                videoElement.className = 'yt-video-result';
                videoElement.innerHTML = `
            <div class="yt-video-thumbnail">
                <img src="${video.thumbnail}" alt="${video.title}">
            </div>
            <div class="yt-video-info">
                <h4>${video.title}</h4>
                <button class="btn primary small" onclick="selectYouTubeVideo('${video.url}')">
                    <i class="fas fa-plus"></i> Adicionar
                </button>
            </div>
        `;
                resultsContainer.appendChild(videoElement);
            });
        }


        /**
         * Lida com a tecla Enter no input de busca do YouTube.
         */
        function handleYTSearchKeyPress(event) {
            // Verifica se a tecla pressionada foi 'Enter'
            if (event.key === 'Enter') {
                searchYouTube(); //
            }
        }
        /* --- FIM DA NOVA FUNÇÃO --- */
        // ====================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyCDlr4XHXuwWQ9Zj9dd2yoctLhFz1vbbyM",
            authDomain: "flowlink-7fd57.firebaseapp.com",
            databaseURL: "https://flowlink-7fd57-default-rtdb.firebaseio.com",
            projectId: "flowlink-7fd57",
            storageBucket: "flowlink-7fd57.firebasestorage.app",
            messagingSenderId: "1035085936175",
            appId: "1:1035085936175:web:2732042d77792118b8f8da",
            measurementId: "G-B0NE1GDVQK"
        };

        // Inicializa o Firebase
        firebase.initializeApp(firebaseConfig);

        // Obtém uma referência para o Realtime Database
        const database = firebase.database();

        // ====================================================================
        // INÍCIO DA MODIFICAÇÃO PARA SALAS
        // ====================================================================

        // 1. Pega o ID da sala da URL IMEDIATAMENTE.
        const urlParams = new URLSearchParams(window.location.search);
        const currentRoomId = urlParams.get('room');

        // 2. Se não houver ID, pare tudo e mostre um erro.
        if (!currentRoomId) {
            // Trava o body e mostra o erro
            document.body.style.overflow = 'hidden';
            document.body.innerHTML = `
                <div class="container" style="margin-top: 50px; text-align: center;">
                    <div class="card" style="padding: 40px;">
                        <h1><i class="fas fa-exclamation-triangle"></i> Erro: Sala não encontrada</h1>
                        <p style="color: var(--text-primary); font-size: 1.1rem; margin: 20px 0;">
                            Este link é inválido. Você precisa de um link de sala para usar o FlowLink.
                        </p>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 30px;">
                            (Ex: index.html?room=minha-sala-123)
                        </p>
                        <a href="create.html" class="btn primary" style="width: auto; padding: 14px 28px;">
                            <i class="fas fa-plus-circle"></i> Criar uma Nova Sala
                        </a>
                    </div>
                </div>`;

            // Para a execução do script para evitar mais erros
            throw new Error("ID da Sala (room) não fornecido na URL.");
        }

        // 3. Se temos um ID, defina TODAS as suas referências para usar esse ID.
        // Crie uma referência principal para a sala
        const roomRef = database.ref('rooms/' + currentRoomId);

        // 4. Substitua suas definições de const originais por estas:
        const videoQueueRef = roomRef.child('videoQueue');

        const playerStateRef = roomRef.child('playerState');
        // ====================================================================
        // NOVO: Sistema de Presença em Tempo Real (MODIFICADO)
        // ====================================================================

        const presenceRef = roomRef.child('presence'); // <--- MODIFICADO
        const connectedRef = database.ref('.info/connected'); // (Este fica igual)
        let myPresenceRef = null; // Guardará a nossa própria referência de conexão

        // Monitora o status da conexão com o Firebase
        connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
                // Estamos conectados!
                console.log('Firebase conectado. Registrando presença na sala: ' + currentRoomId);

                // Pega o nome da sessão, se já existir
                let userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

                // Cria uma nova entrada única para este usuário na lista de presença DESTA SALA
                myPresenceRef = presenceRef.push();

                // Define o onDisconnect PRIMEIRO
                myPresenceRef.onDisconnect().remove();

                // Agora, define nosso estado online com nosso nome
                myPresenceRef.set({
                    name: userName,
                    joinedAt: firebase.database.ServerValue.TIMESTAMP
                });

            } else {
                // Estamos desconectados
                console.log('Firebase desconectado.');
            }
        });

        // Coloque isso perto de onde você define o roomRef

        const roomNameDisplay = document.getElementById('roomNameDisplay');
        const roomCreatorDisplay = document.getElementById('roomCreatorDisplay');

        // Listener para os dados da sala
        roomRef.on('value', (snapshot) => {
            const roomData = snapshot.val();
            if (roomData) {
                const roomName = roomData.roomName || 'Sala FlowLink';
                const creatorName = roomData.creatorName || 'Desconhecido';

                if (roomNameDisplay) {
                    roomNameDisplay.textContent = roomName;
                }
                if (roomCreatorDisplay) {
                    roomCreatorDisplay.textContent = creatorName;
                }

                // Bônus: Atualiza o título da aba do navegador!
                document.title = `${roomName} - FlowLink`;
            }
        });



       // Monitora usuários online
        const userCountElement = document.getElementById('userCount');
        presenceRef.on('value', (snap) => {
            onlineUserCount = snap.numChildren(); 

            // --- CORREÇÃO DE LIDERANÇA ---
            // Se estou sozinho, assumo a liderança (Broadcaster).
            // IMPORTANTE: Se entrar gente depois, eu CONTINUO sendo true.
            // Se eu sair e sobrar 1 pessoa, ela vira true.
            if (onlineUserCount <= 1) {
                isBroadcaster = true;
                console.log('Você é o Líder da Sincronização (Broadcaster).');
            }
            // -----------------------------

            // Lógica de Classes CSS (Mantenha igual)
            if (onlineUserCount > 1) {
                document.body.classList.add('festa-mode');
                document.body.classList.remove('solo-mode');
            } else {
                document.body.classList.add('solo-mode');
                document.body.classList.remove('festa-mode');
            }
            
            // ... (o resto do código mantém igual: botões, contadores, updatePlayerMode) ...
             const shouldHide = (onlineUserCount > 1) && !isAdminLoggedIn;
            const removeButtons = document.querySelectorAll('.remove-button, .bulk-delete-controls');
            
            removeButtons.forEach(el => {
                if (shouldHide) {
                    el.style.setProperty('display', 'none', 'important');
                } else {
                    el.style.removeProperty('display'); 
                }
            });

            if (userCountElement) userCountElement.textContent = onlineUserCount;
            const chatOnlineCount = document.getElementById('onlineCount');
            if (chatOnlineCount) chatOnlineCount.textContent = onlineUserCount;

            updatePlayerMode();
        });
        // ====================================================================
        // Fim do Sistema de Presença
        // ====================================================================

        // ====================================================================
        // NOVO: Funções de Sessão de Admin (Login/Logout)
        // ====================================================================

        function openAdminUnlockModal() {
            // Se o admin já estiver logado, o botão vira "Logout"
            if (isAdminLoggedIn) {
                logoutAdminSession();
                document.body.classList.add('non-admin');
                disableAdminPlayerControls();

                return; // Não abre o modal
            }
            // Se não, abre o modal de login
            document.getElementById('adminUnlockModal').style.display = 'flex';
            document.getElementById('adminUnlockName').focus();
        }

        function closeAdminUnlockModal() {
            document.getElementById('adminUnlockModal').style.display = 'none';
            document.getElementById('adminUnlockName').value = '';
            document.getElementById('adminUnlockPassword').value = '';
        }

        // NOVO: Fecha o modal de confirmação de remoção em lote
        function closeBulkRemoveConfirmModal() {
            document.getElementById('bulkRemoveConfirmModal').style.display = 'none';
            // Limpa o array de IDs para garantir
            videoIdsForBulkRemove = [];
        }

        async function loginAdminSession() {
            const adminEmail = document.getElementById('adminUnlockName').value.trim();
            const password = document.getElementById('adminUnlockPassword').value;
            document.body.classList.remove('non-admin');

            enableAdminPlayerControls();

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha e-mail e senha.', 'error');
                return;
            }

            toggleLoading('adminUnlockConfirmBtn', true);

            try {
                // Tenta fazer o login no Firebase Auth
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // SUCESSO!
                isAdminLoggedIn = true; // Define o estado global
                const adminBtn = document.getElementById('adminUnlockBtn');
                adminBtn.classList.add('admin-logged-in'); // Deixa o botão verde
                adminBtn.innerHTML = '<i class="fas fa-unlock"></i> Admin'; // Muda o ícone
                document.body.classList.remove('non-admin');
                showNotification('Modo Admin ATIVADO.', 'success');
                closeAdminUnlockModal();

                // *** PARTE 2: Mostra os controles de admin ***
                document.getElementById('panelBtn').style.display = 'flex';
                document.getElementById('videoList').classList.add('admin-mode');
                document.getElementById('bulkRemoveBtn').style.display = 'inline-block';
                document.getElementById('clearChatBtn').style.display = 'inline-block';

                enableAdminPlayerControls();
            } catch (error) {
                console.error('Erro de autenticação do admin:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido.', 'error');
                } else {
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('adminUnlockConfirmBtn', false);
            }
        }


        function disableAdminPlayerControls() {
            console.log('Desativando Modo Admin...');
            // Quando o admin sai, a lógica de solo/festa assume.
            // Não precisamos recriar o player aqui, apenas chamamos a função correta.
            const userCount = parseInt(document.getElementById('userCount').textContent, 10) || 0;
            if (userCount === 1) {
                enableSoloPlayerControls();
            } else {
                disableSoloPlayerControls();
            }
        }

        function enableAdminPlayerControls() {
            console.log('Ativando Modo Admin Completo...');
            const currentTime = player ? player.getCurrentTime() : 0;
            let currentVideoId = null;

            if (videoQueue.length > 0) {
                currentVideoId = extractVideoId(videoQueue[0].videoUrl);
            }

            if (player) {
                player.destroy();
            }

            // 1. Recria o player com controles nativos
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                videoId: currentVideoId,
                playerVars: {
                    autoplay: 1,
                    controls: 1,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onReady: (event) => {
                        if (currentVideoId) event.target.seekTo(currentTime);
                        event.target.playVideo();
                        document.getElementById('player-mask').style.display = 'none';
                    },
                    onStateChange: onPlayerStateChange
                }
            });

            // 2. Garante que o overlay customizado está escondido
            const overlay = document.querySelector('.player-overlay-controls');
            if (overlay) overlay.style.display = 'none';

            // 3. MOSTRA O BOTÃO "LIMPAR FILA" (A CORREÇÃO PRINCIPAL)
            document.querySelector('.clear-queue-button').style.display = 'inline-block';

            // 4. Garante que o botão de pular está visível e com texto de Admin
            document.querySelector('.skip-video-button').style.display = 'inline-block';
            document.getElementById('skipVoteBtnText').textContent = 'Pular Vídeo (Admin)';
            document.getElementById('voteCounterWrapper').style.display = 'none';
        }

        /**
         * NOVO: Habilita os controles do player para o modo "solo".
         * (Usuário está sozinho na sala, mas não é admin)
         */
        function enableSoloPlayerControls() {
            console.log('Ativando Modo Solo...');
            const currentTime = player ? player.getCurrentTime() : 0;
            let currentVideoId = null;

            if (videoQueue.length > 0) {
                currentVideoId = extractVideoId(videoQueue[0].videoUrl);
            }

            // Se o player já existe e já é SOLO, apenas reaproveita (Otimização do Solo)
            if (player && currentPlayerMode === 'SOLO' && typeof player.loadVideoById === 'function') {
                if (currentVideoId) {
                    player.loadVideoById(currentVideoId);
                }
                return;
            }

            // Se não era SOLO ou não existia, recria
            if (player) {
                player.destroy();
            }

            currentPlayerMode = 'SOLO'; // <--- MARCA COMO SOLO

            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                videoId: currentVideoId,
                playerVars: {
                    autoplay: 1,
                    controls: 1, // TEM CONTROLES
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onReady: (event) => {
                        if (currentVideoId) event.target.seekTo(currentTime);
                        event.target.playVideo();
                        document.getElementById('player-mask').style.display = 'none';
                    },
                    onStateChange: onPlayerStateChange
                }
            });

            const overlay = document.querySelector('.player-overlay-controls');
            if (overlay) overlay.style.display = 'none';

            document.querySelector('.clear-queue-button').style.display = 'inline-block';
            document.querySelector('.skip-video-button').style.display = 'inline-block';
            document.getElementById('skipVoteBtnText').textContent = 'Pular (Modo Solo)';
            document.getElementById('voteCounterWrapper').style.display = 'none';
        }

        /**
         * Desabilita os controles do player quando mais alguém entra.
         * (Volta ao modo "festa" padrão)
         */
       function disableSoloPlayerControls() {
    console.log('Ativando Modo Festa (Otimizado + Sem Reinício)...');

    // 1. SALVA O TEMPO ATUAL (Para a música não voltar ao início)
    let savedTime = 0;
    try {
        if (player && typeof player.getCurrentTime === 'function') {
            savedTime = player.getCurrentTime();
        }
    } catch (e) { console.warn('Erro ao salvar tempo:', e); }

    // Pega o vídeo da fila
    let currentVideoId = null;
    if (typeof videoQueue !== 'undefined' && videoQueue.length > 0) {
        currentVideoId = extractVideoId(videoQueue[0].videoUrl);
    }

    // 2. Se não estiver no modo FESTA, destrói o player (para tirar controles)
    if (player && currentPlayerMode !== 'FESTA') {
        console.log(`Mudança de modo detectada. Recriando player mantendo o tempo: ${savedTime}s`);
        try { player.destroy(); } catch (e) {}
        player = null; 
    }

    // 3. Se o player sobreviveu (já era FESTA), apenas garante o vídeo certo
    if (player && typeof player.loadVideoById === 'function') {
        // Verifica se o vídeo que está tocando é o mesmo da fila
        let playingId = null;
        try { playingId = player.getVideoData().video_id; } catch(e){}

        if (currentVideoId && playingId !== currentVideoId) {
            player.loadVideoById(currentVideoId); // Só carrega se mudou a música
        }
        
        // Garante máscara
        const mask = document.getElementById('player-mask');
        if (mask) mask.style.display = 'block';
    } 
    // 4. Se precisa criar um novo player (sem barra)
    else {
        // Limpeza final de segurança
        if (player) { try { player.destroy(); } catch (e) {} }

        currentPlayerMode = 'FESTA';

        if (currentVideoId) {
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                videoId: currentVideoId,
                playerVars: {
                    'autoplay': 1,
                    'controls': 0, // SEM BARRA
                    'modestbranding': 1,
                    'rel': 0,
                    'disablekb': 1,
                    'iv_load_policy': 3,
                    'fs': 0,
                    'start': Math.floor(savedTime) // Tenta iniciar no tempo certo via parametro
                },
                events: {
                    'onReady': (event) => {
                        // GARANTIA EXTRA: Pula para o tempo salvo assim que carregar
                        if (savedTime > 0) {
                            event.target.seekTo(savedTime, true);
                        }
                        event.target.playVideo();
                        const mask = document.getElementById('player-mask');
                        if (mask) mask.style.display = 'block';
                    },
                    'onStateChange': onPlayerStateChange
                }
            });
        } else {
            console.log('Fila vazia no Modo Festa.');
            const container = document.getElementById('videoPlayer');
            if (container) container.innerHTML = '<div style="height:100%; display:flex; align-items:center; justify-content:center; color:white;">Aguardando músicas...</div>';
        }
    }

    // Atualiza Botões da Interface
    const overlay = document.querySelector('.player-overlay-controls');
    if (overlay) overlay.style.display = 'flex'; // Overlay customizado aparece

    const clearBtn = document.querySelector('.clear-queue-button');
    if (clearBtn) clearBtn.style.display = 'none'; // Botão de limpar fila some

    const skipBtn = document.querySelector('.skip-video-button');
    if (skipBtn) skipBtn.style.display = 'inline-block';

    const skipText = document.getElementById('skipVoteBtnText');
    if (skipText) skipText.textContent = 'Votar para Pular';

    const voteWrapper = document.getElementById('voteCounterWrapper');
    if (voteWrapper) voteWrapper.style.display = 'inline';
}

        function logoutAdminSession() {

            document.getElementById('panelBtn').style.display = 'none';

            isAdminLoggedIn = false;
            currentAdminUser = null;
            document.body.classList.add('non-admin');

            // Atualiza a exibição
            updateAdminDisplay();

            showNotification('Modo Admin DESATIVADO.', 'info');

            // Esconde os controles de admin
            document.getElementById('videoList').classList.remove('admin-mode');
            document.getElementById('bulkRemoveBtn').style.display = 'none';
            document.getElementById('clearChatBtn').style.display = 'none';
            // Limpa os checkboxes
            document.querySelectorAll('.video-select-checkbox').forEach(cb => cb.checked = false);
            // Restaura o botão de pular para o modo Votação
            document.getElementById('skipVoteBtnText').textContent = 'Votar para Pular';
            document.getElementById('voteCounterWrapper').style.display = 'inline';

            // Trava o player (estado padrão de não-admin)
            disableAdminPlayerControls();

            // --- INÍCIO DA NOVA LÓGICA PÓS-LOGOUT ---
            // Verifica a contagem atual para decidir o que fazer com os controles
            const userCount = parseInt(document.getElementById('userCount').textContent, 10) || 0;

            if (userCount === 1) {
                // Se o usuário ficou sozinho, reativa o Modo Solo
                console.log('Admin saiu. Usuário está sozinho. Reativando Modo Solo.');
                enableSoloPlayerControls();
            } else {
                // Se há mais gente, garante que o botão de limpar fila está escondido
                console.log('Admin saiu. Modo Festa ativado.');
                document.querySelector('.clear-queue-button').style.display = 'none';
                document.querySelector('.skip-video-button').style.display = 'inline-block'; // Garante que votação está visível
            }
            // --- FIM DA NOVA LÓGICA ---
        }

        // Adiciona o listener do "olho" da senha para o novo modal
        document.getElementById('toggleAdminUnlockPassword').addEventListener('click', function () {
            const passwordField = document.getElementById('adminUnlockPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        let onlineUserCount = 0; // Para guardar a contagem de usuários
        let isPlayerReady = false; // "Guarda" que diz se o player está pronto
        let videoQueue = []; // Array local para espelhar a fila do Firebase
        let player; // Variável para o player do YouTube
        let currentPlayerMode = null;
        let videoToRemoveId = null; // ID do vídeo a ser removido (usado no modal de remoção)
        let isAdminLoggedIn = false; // NOVO: Estado de login do Admin
        let videoIdsForBulkRemove = [];
        let notificationTimer = null;
        let isBroadcaster = false;

        // Variável GLOBAL para o intervalo de sincronização
        let syncInterval = null;

        function startSyncHeartbeat() {
            if (syncInterval) clearInterval(syncInterval);
            console.log("Iniciando batimento cardíaco de sincronização...");
            
            syncInterval = setInterval(() => {
                // CORREÇÃO: Usa 'isBroadcaster' em vez de contagem de usuários
                if ((isAdminLoggedIn || isBroadcaster) && player && typeof player.getPlayerState === 'function') {
                    if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                        playerStateRef.update({
                            timestamp: firebase.database.ServerValue.TIMESTAMP,
                            videoTime: player.getCurrentTime()
                        });
                    }
                }
            }, 5000); 
        }
        /**
 * Exibe uma notificação temporária na tela.
 * (Versão corrigida para evitar bugs de 'race condition')
 * @param {string} message - A mensagem a ser exibida.
 * @param {string} [type='info'] - O tipo da notificação ('info', 'success', 'error').
 */
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notificationMessage');

            // 1. Limpa qualquer timer de notificação anterior
            // Isso impede que a notificação desapareça se uma nova for chamada
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }

            notificationMessage.textContent = message;
            notification.className = 'notification'; // Reseta as classes
            notification.classList.add(type, 'show'); // Adiciona as novas

            // 2. Define um NOVO timer para 5 segundos (aumentado de 3000)
            notificationTimer = setTimeout(() => {
                notification.classList.remove('show');
                notificationTimer = null; // Limpa o ID do timer
            }, 5000); // <-- Aumentado de 3000ms para 5000ms
        }


        /**
         * Alterna o estado de carregamento de um botão (mostra/oculta um spinner).
         * @param {string} buttonId - O ID do botão.
         * @param {boolean} isLoading - True para mostrar o carregamento, false para ocultar.
         */
        function toggleLoading(buttonId, isLoading) {
            const btn = document.getElementById(buttonId);
            const btnText = btn ? btn.querySelector(`#${buttonId.replace('Btn', 'BtnText')}`) : null;
            const btnLoader = btn ? btn.querySelector(`#${buttonId.replace('Btn', 'BtnLoader')}`) : null;

            if (!btn || !btnText || !btnLoader) {
                console.error(`Um ou mais elementos para o botão ${buttonId} não foram encontrados.`);
                return;
            }

            if (isLoading) {
                btn.disabled = true;
                btnText.style.display = 'none';
                btnLoader.style.display = 'inline-block';
            } else {
                btn.disabled = false;
                btnText.style.display = 'inline';
                btnLoader.style.display = 'none';
            }
        }

        /**
         * Adiciona um novo vídeo à fila no Firebase Realtime Database.
         */
        async function addVideo() {
            const phone = document.getElementById('phone').value.trim();
            const videoUrl = document.getElementById('videoUrl').value.trim();

            if (!phone || !videoUrl) {
                showNotification('Por favor, preencha o nome e a URL do vídeo.', 'error');
                return;
            }

            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            if (!youtubeRegex.test(videoUrl)) {
                showNotification('Por favor, insira uma URL de vídeo válida do YouTube.', 'error');
                return;
            }

            toggleLoading('addVideoBtn', true);

            try {
                const newVideoRef = videoQueueRef.push();
                await newVideoRef.set({
                    id: newVideoRef.key,
                    phone: phone,
                    videoUrl: videoUrl
                });

                showNotification('Vídeo adicionado com sucesso!', 'success');

                document.getElementById('phone').value = '';
                document.getElementById('videoUrl').value = '';

            } catch (error) {
                console.error('Erro ao adicionar vídeo ao Firebase:', error);
                showNotification('Erro ao adicionar o vídeo. Verifique a conexão com o Firebase.', 'error');
            } finally {
                toggleLoading('addVideoBtn', false);
            }
        }

        /**
         * Carrega a fila de vídeos do Firebase Realtime Database e atualiza a UI.
         * Esta função usa um listener 'value' que é acionado sempre que os dados na referência mudam.
         */
        function loadVideoQueue() {
            videoQueueRef.on('value', async (snapshot) => {
                const data = snapshot.val();
                let fetchedQueue = [];

                if (data) {
                    fetchedQueue = Object.keys(data).map(key => ({
                        id: key,
                        ...data[key]
                    }));
                }

                videoQueue = fetchedQueue;
                const videoList = document.getElementById('videoList');
                videoList.innerHTML = '';
                // NOVO: Aplica a classe de admin se estiver logado
                if (isAdminLoggedIn) {
                    videoList.classList.add('admin-mode');
                } else {
                    videoList.classList.remove('admin-mode');
                }



                if (videoQueue.length === 0) {
                    videoList.innerHTML = '<li class="empty-queue">A fila de vídeos está vazia. Adicione um vídeo!</li>';
                    document.getElementById('currentUser').textContent = 'Nenhum vídeo em execução';
                    document.getElementById('currentVideoUrl').textContent = 'Nenhuma URL disponível';
                    if (player && typeof player.stopVideo === 'function') {
                        player.stopVideo();
                    }
                    return;
                }

                async function getFormattedVideoTitle(url) {
                    try {
                        // Tenta pegar do cache primeiro
                        const videoId = extractVideoId(url);
                        const cachedTitle = sessionStorage.getItem(`videoTitle_${videoId}`);

                        if (cachedTitle) {
                            return cachedTitle;
                        }

                        // CÓDIGO NOVO (SEGURO)
                        // Chama o seu servidor em vez do YouTube direto
                        const response = await fetch(`/api/video-info?id=${videoId}`);

                        if (response.ok) {
                            const data = await response.json();
                            if (data.items && data.items[0]) {
                                const title = data.items[0].snippet.title;
                                // Armazena no cache para próximas vezes
                                sessionStorage.setItem(`videoTitle_${videoId}`, title);
                                return title;
                            }
                        }
                    } catch (error) {
                        console.error('Erro ao buscar título:', error);
                    }

                    // Fallback: Mostra "Música (ID do vídeo)" se não conseguir o título
                    const videoId = extractVideoId(url);
                    return videoId ? `Música (ID: ${videoId})` : 'Vídeo do YouTube';
                }
                // Preenche a lista na UI com títulos melhorados
                for (const video of videoQueue) {
                    const listItem = document.createElement('li');
                    listItem.classList.add('video-item');

                    // Obtém o título formatado
                    const videoTitle = await getFormattedVideoTitle(video.videoUrl);

                    listItem.innerHTML = `
            <div class="bulk-delete-controls">
                <input type="checkbox" class="video-select-checkbox" data-videoid="${video.id}" title="Selecionar para remover">
            </div>

            <div class="video-info">
                <span class="video-title">${videoTitle}</span>
                <div class="video-meta">
                    <span class="video-added-by">Adicionado por: ${video.phone}</span>
                    <a href="${video.videoUrl}" target="_blank" class="video-link">
                        <i class="fab fa-youtube"></i> Assistir
                    </a>
                </div>
            </div>
           <button class="remove-button" onclick="handleRemoveVideo('${video.id}')" title="Remover vídeo">
                <i class="fas fa-times"></i>
            </button>
        `;
        // Verifica se deve esconder o botão logo ao criar
        if (onlineUserCount > 1 && !isAdminLoggedIn) {
                    const btns = listItem.querySelectorAll('.remove-button, .bulk-delete-controls');
                    btns.forEach(b => b.style.setProperty('display', 'none', 'important'));
                }
                    videoList.appendChild(listItem);
                }

                // Mantém a lógica do player
                let currentlyPlayingVideoIdInPlayer = null;
                if (player && typeof player.getVideoData === 'function') {
                    try {
                        currentlyPlayingVideoIdInPlayer = player.getVideoData().video_id;
                    } catch (e) {
                        console.warn("Player.getVideoData() falhou:", e);
                    }
                }

                const firstVideoInQueue = videoQueue[0];
                const firstVideoInQueueId = extractVideoId(firstVideoInQueue.videoUrl);

                if (player && typeof player.loadVideoById === 'function') {
                    const firstVideoInQueue = videoQueue[0];
                    const firstVideoInQueueId = extractVideoId(firstVideoInQueue.videoUrl);

                    // Obter o ID do vídeo atualmente carregado no player, se houver
                    let currentlyLoadedVideoId = null;
                    if (player.getVideoData && typeof player.getVideoData === 'function') {
                        try {
                            currentlyLoadedVideoId = player.getVideoData().video_id;
                        } catch (e) {
                            console.warn("Player.getVideoData() falhou ou player não está pronto para obter dados do vídeo:", e);
                        }
                    }

                    // Apenas carregue um novo vídeo se:
                    // 1. Não houver nenhum vídeo carregado no player (início).
                    // 2. O ID do primeiro vídeo na fila for diferente do vídeo atualmente carregado.
                    // 3. (Opcional, mas recomendado) O player não estiver no estado de "playing" E o vídeo que deveria tocar for o primeiro da fila
                    //    Isso serve para garantir que ele reinicie se o vídeo atual for o certo, mas ele parou por algum motivo (erro, etc.)
                    if (currentlyLoadedVideoId === null ||
                        currentlyLoadedVideoId !== firstVideoInQueueId ||
                        (player.getPlayerState() !== YT.PlayerState.PLAYING && currentlyLoadedVideoId === firstVideoInQueueId)
                    ) {
                        updateVideoPlayer(firstVideoInQueue.videoUrl, firstVideoInQueue.phone);
                    }
                } else {
                    console.warn('Player do YouTube não está pronto para carregar o vídeo.');
                }
            });
        }

        /**
         * Extrai o ID do vídeo de uma URL do YouTube.
         * @param {string} url - A URL do YouTube.
         * @returns {string|null} O ID do vídeo ou null se não for uma URL válida.
         */
        function extractVideoId(url) {
            const regExp = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            const match = url.match(regExp);
            return (match && match[1]) ? match[1] : null;
        }

        /**
         * Obtém um título genérico para o vídeo com base no ID.
         * @param {string} url - A URL do vídeo.
         * @returns {string} O título do vídeo.
         */
        function getVideoTitle(url) {
            const videoId = extractVideoId(url);
            return videoId ? `Vídeo (ID: ${videoId})` : 'Vídeo do YouTube'; // Ou você pode usar uma API para obter o título real
        }

        /**
         * Carrega e reproduz um vídeo no player do YouTube.
         * @param {string} videoUrl - A URL do vídeo a ser carregado.
         * @param {string} userName - O nome do usuário que adicionou o vídeo.
         */
        function updateVideoPlayer(videoUrl, userName) {
            const videoId = extractVideoId(videoUrl);

            if (videoId && player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoId);
                document.getElementById('currentUser').textContent = userName;
                document.getElementById('currentVideoUrl').textContent = videoUrl;
            } else {
                console.error('URL do YouTube inválida ou player não pronto:', videoUrl);
                document.getElementById('currentUser').textContent = 'Nenhum vídeo em execução';
                document.getElementById('currentVideoUrl').textContent = 'Nenhuma URL disponível';
                if (player && typeof player.stopVideo === 'function') {
                    player.stopVideo();
                }
            }
        }

        /**
         * Função chamada quando o estado do player do YouTube muda.
         * Se o vídeo terminar, ele remove o vídeo atual da fila do Firebase.
         * O listener 'value' do Firebase se encarrega de carregar o próximo.
         * @param {Object} event - O objeto de evento do player do YouTube.
         */
        let lastKnownTime = 0;
        let timeCheckInterval;

        function startProgressMonitor() {
            if (timeCheckInterval) {
                clearInterval(timeCheckInterval);
            }

            timeCheckInterval = setInterval(() => {
                if (player && typeof player.getCurrentTime === 'function' && player.getPlayerState() === YT.PlayerState.PLAYING) {
                    const currentTime = player.getCurrentTime();
                    const duration = player.getDuration();

                    const jumpThreshold = 5; // Se avançar mais que 5s
                    const remainingTimeThreshold = 50; // E estiver nos últimos 5s

                    const jumped = currentTime > lastKnownTime + jumpThreshold;
                    const nearEnd = currentTime >= duration - remainingTimeThreshold && currentTime < duration;

                    if (jumped && !nearEnd) {
                        console.log('Detectado adiantamento no vídeo.');
                    } else if (jumped && nearEnd) {
                       if (isAdminLoggedIn || onlineUserCount <= 1) {
                            console.log('Adiantamento para o final permitido (Admin/Solo).');
                            // Não faz nada, deixa o código continuar e atualizar o tempo.
                        } 
                        else {
                            // Se for Visitante EM GRUPO, aí sim BLOQUEIA.
                            console.log('Bloqueando adiantamento para o final (Visitante).');
                            player.pauseVideo();
                            player.seekTo(lastKnownTime + 1, true);
                            showNotification('Você não pode adiantar o vídeo até o final.', 'error');
                            return; // ← Sai da função para não validar a trapaça
                        }
                    }

                    // Só atualiza se não houver adiantamento suspeito
                    lastKnownTime = currentTime;
                }
            }, 1000);
        }


        function onPlayerStateChange(event) {
            // 1. ATIVA O MONITORAMENTO (Anti-adiantamento)
            if (event.data === YT.PlayerState.PLAYING) {
                startProgressMonitor();
            } else {
                if (typeof timeCheckInterval !== 'undefined' && timeCheckInterval) {
                    clearInterval(timeCheckInterval);
                }
            }

            // =================================================================
            // NOVA LÓGICA DE SINCRONIZAÇÃO (O "CÉREBRO")
            // =================================================================
            // Apenas quem tem "controle" deve atualizar o Firebase.
            // Regra: Se for Admin OU se estiver sozinho (Solo) -> Atualiza o banco.
            // Se estiver no Modo Festa sem admin -> O vídeo toca automático, então quem carregou primeiro manda.
            // Para simplificar: Vamos deixar o Admin ou o Modo Solo mandarem.
            
            if (isAdminLoggedIn || isBroadcaster) {
                 const currentTime = player.getCurrentTime();
                 
                 if (event.data === YT.PlayerState.PLAYING) {
                     playerStateRef.set({
                         status: 'playing',
                         videoId: player.getVideoData().video_id,
                         timestamp: firebase.database.ServerValue.TIMESTAMP, // Hora exata do servidor
                         videoTime: currentTime // Onde o vídeo estava
                     });
                 } 
                 else if (event.data === YT.PlayerState.PAUSED) {
                     playerStateRef.set({
                         status: 'paused',
                         videoId: player.getVideoData().video_id,
                         timestamp: firebase.database.ServerValue.TIMESTAMP,
                         videoTime: currentTime
                     });
                 }
            }
            // =================================================================

            // 2. Lógica de Fim de Vídeo (Seu código original)
            if (event.data === YT.PlayerState.ENDED) {
                // ... (seu código de remover vídeo mantém igual) ...
                 const currentTime = player.getCurrentTime();
                 const duration = player.getDuration();
                 const naturalEndTolerance = 2.0;

                 if (duration - currentTime <= naturalEndTolerance) {
                    console.log('Vídeo terminou naturalmente. Avançando...');
                    if (videoQueue.length > 0) {
                        const firstVideoInQueue = videoQueue[0];
                        const currentId = player.getVideoData().video_id;
                        const queueId = extractVideoId(firstVideoInQueue.videoUrl);
                        if (currentId === queueId) {
                            videoQueueRef.child(firstVideoInQueue.id).remove();
                        }
                    }
                 } else {
                     player.stopVideo();
                 }
            }
        }
        

        // Função para atualizar a exibição do nome do admin
        function updateAdminDisplay() {
            const adminBtn = document.getElementById('adminUnlockBtn');
            const adminStatusText = document.getElementById('adminStatusText');
            const adminNameDisplay = document.getElementById('adminNameDisplay');
            const adminInfo = document.getElementById('adminInfo');
            const adminFullName = document.getElementById('adminFullName');

            if (isAdminLoggedIn && currentAdminUser) {
                adminBtn.classList.add('admin-logged-in');
                adminStatusText.textContent = 'Admin:';
                adminNameDisplay.textContent = currentAdminUser;
                adminNameDisplay.style.display = 'inline';

                // Mostra info adicional se existir
                if (adminInfo && adminFullName) {
                    adminFullName.textContent = currentAdminUser;
                    adminInfo.style.display = 'flex';
                }
            } else {
                adminBtn.classList.remove('admin-logged-in');
                adminStatusText.textContent = 'Admin';
                adminNameDisplay.style.display = 'none';
                adminNameDisplay.textContent = '';

                // Esconde info adicional se existir
                if (adminInfo) {
                    adminInfo.style.display = 'none';
                }
            }
        }

        // Variável para armazenar o nome do admin logado
        let currentAdminUser = null;

        // Modifique a função loginAdminSession para armazenar o nome do admin
        async function loginAdminSession() {
            const adminEmail = document.getElementById('adminUnlockName').value.trim();
            const password = document.getElementById('adminUnlockPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha e-mail e senha.', 'error');
                return;
            }

            toggleLoading('adminUnlockConfirmBtn', true);

            try {
                // Tenta fazer o login no Firebase Auth
                const userCredential = await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // SUCESSO!
                isAdminLoggedIn = true;
                currentAdminUser = adminEmail.split('@')[0]; // Pega a parte antes do @ como nome
                document.body.classList.remove('non-admin');

                // Atualiza a exibição do nome no botão
                updateAdminDisplay();
                closeAdminUnlockModal();

                // Mostra os controles GERAIS de admin (painel, remoção em lote, etc.)
                document.getElementById('videoList').classList.add('admin-mode');
                document.getElementById('bulkRemoveBtn').style.display = 'inline-block';
                document.getElementById('clearChatBtn').style.display = 'inline-block';
                document.getElementById('panelBtn').style.display = 'flex';

                // CHAMA A FUNÇÃO CENTRALIZADA para cuidar do player e botões associados
                enableAdminPlayerControls();

            } catch (error) {
                console.error('Erro de autenticação do admin:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido.', 'error');
                } else {
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('adminUnlockConfirmBtn', false);
            }
        }


        function logoutAdminSession() {

            document.getElementById('panelBtn').style.display = 'none';

            isAdminLoggedIn = false;
            currentAdminUser = null;
            document.body.classList.add('non-admin');

            // Atualiza a exibição
            updateAdminDisplay();

            showNotification('Modo Admin DESATIVADO.', 'info');

            // Esconde os controles de admin
            document.getElementById('videoList').classList.remove('admin-mode');
            document.getElementById('bulkRemoveBtn').style.display = 'none';
            document.getElementById('clearChatBtn').style.display = 'none';
            // Limpa os checkboxes
            document.querySelectorAll('.video-select-checkbox').forEach(cb => cb.checked = false);
            // Restaura o botão de pular para o modo Votação
            document.getElementById('skipVoteBtnText').textContent = 'Votar para Pular';
            document.getElementById('voteCounterWrapper').style.display = 'inline';
            disableAdminPlayerControls();
        }

        /**
                 * Função "portão" que decide se deve VOTAR ou PULAR (admin).
                 * Esta função é chamada pelo botão principal de skip.
                 */
        function handleSkipOrVote() {
            // NOVO: Verifica a contagem de usuários diretamente
            const userCount = parseInt(document.getElementById('userCount').textContent, 10) || 0;

            // Se for admin OU se estiver sozinho na sala, pula direto
            if (isAdminLoggedIn || userCount === 1) {
                console.log('Admin ou Modo Solo. Pulando vídeo (via handleSkipOrVote)...');
                executeSkipVideo(); // Esta é a função de skip direto
            } else {
                // Usuário normal em grupo: Registra um voto
                console.log('Usuário normal em grupo. Registrando voto para pular (via handleSkipOrVote)...');
                castVoteToSkip(); // Esta é a função de votação
            }
        }
        // Variável para armazenar o ID do vídeo a ser removido (o que acabou de tocar)
        // (Mantenha esta variável no escopo global ou onde 'videoToRemoveId' está)
        /**
                 * Função "portão" para pular o vídeo.
                 * Verifica se o admin está logado. Se sim, pula direto.
                 * Se não, abre o modal de autenticação.
                 */
        function handleSkipVideo() {
            // Verifica se a fila está vazia
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return;
            }

            if (isAdminLoggedIn) {
                // Admin está logado: executa a lógica de pular diretamente
                console.log('Admin logado. Pulando vídeo...');
                executeSkipVideo(); // Não precisa de 'await'
            } else {
                // Admin não está logado: abre o modal para pedir credenciais
                console.log('Admin não logado. Abrindo modal de autenticação...');
                openNextVideoModal();
            }
        }

        /**
         * Abre o modal para avançar para o próximo vídeo, pedindo credenciais do admin.
         */
        function openNextVideoModal() {
            // Se a fila estiver vazia, não há próximo vídeo para avançar
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return;
            }

            // O ID do vídeo que está atualmente em execução (o primeiro da fila)
            // será o que será removido quando o admin confirmar.


            document.getElementById('nextVideoModal').style.display = 'flex';
            document.getElementById('nextAdminName').focus(); // Foca no campo de nome
        }

        /**
         * Fecha o modal de "Próximo Vídeo" e limpa os campos.
         */
        function closeNextVideoModal() {
            document.getElementById('nextVideoModal').style.display = 'none';
            document.getElementById('nextAdminName').value = '';
            document.getElementById('nextPassword').value = '';

        }

        /**
         * Função para avançar para o próximo vídeo na fila, após autenticação do admin.
         */
        async function playNextVideo() {
            const adminEmail = document.getElementById('nextAdminName').value.trim();
            const password = document.getElementById('nextPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha o nome e a senha de administrador.', 'error');
                return;
            }

            // A verificação da fila será feita pela executeSkipVideo, 
            // mas é bom ter aqui para fechar o modal se a fila esvaziou.
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                closeNextVideoModal();
                return;
            }

            toggleLoading('playNextVideoBtn', true);

            try {
                // 1. Tenta autenticar
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // 2. Se autenticou, executa a lógica de pular
                const success = await executeSkipVideo();

                // 3. Se a lógica de pular foi bem-sucedida, fecha o modal
                if (success) {
                    closeNextVideoModal();
                }

            } catch (error) {
                console.error('Erro de autenticação ou ao avançar vídeo:', error);

                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    // Erro genérico de autenticação
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('playNextVideoBtn', false);
            }
        }

        // Event listener para alternar a visibilidade da senha no modal "Próximo Vídeo"
        document.getElementById('toggleNextPassword').addEventListener('click', function () {
            const passwordField = document.getElementById('nextPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        /**
         * Lógica central para avançar o vídeo.
         * Remove o primeiro vídeo da fila.
         * @returns {Promise<boolean>} - Retorna 'true' se foi bem-sucedido, 'false' se falhou.
         */
        async function executeSkipVideo() {
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return false; // Retorna 'false' para indicar falha
            }

            try {
                // O ID do vídeo a ser removido é sempre o primeiro na fila
                const idToRemove = videoQueue[0].id;
                await videoQueueRef.child(idToRemove).remove();

                showNotification('Avançando para o próximo vídeo!', 'success');
                return true; // Retorna 'true' para indicar sucesso
            } catch (error) {
                console.error('Erro ao avançar vídeo:', error);
                showNotification('Erro ao avançar o vídeo. Verifique a conexão.', 'error');
                return false; // Retorna 'false' para indicar falha
            }
        }

        // ====================================================================
        // NOVO: Função de Remoção em Lote
        // ====================================================================
        // Esta função agora APENAS abre o modal de confirmação
        function removeSelectedVideos() {
            // PERMITE se for Admin OU se estiver Sozinho
            if (!isAdminLoggedIn && onlineUserCount > 1) {
                showNotification('Você precisa estar no Modo Admin para fazer isso em grupo.', 'error');
                return;
            }

            // ... (o resto da função continua igual) ...
            // 1. Encontra todos os checkboxes marcados
            const selectedCheckboxes = document.querySelectorAll('.video-select-checkbox:checked');
            
            if (selectedCheckboxes.length === 0) {
                showNotification('Nenhum vídeo selecionado.', 'info');
                return;
            }

            // ... lógica de abrir modal de confirmação ...
            videoIdsForBulkRemove = Array.from(selectedCheckboxes).map(cb => cb.dataset.videoid);
            document.getElementById('bulkRemoveMessage').textContent = `Remover ${videoIdsForBulkRemove.length} vídeos?`;
            document.getElementById('bulkRemoveConfirmModal').style.display = 'flex';
        }

        // NOVO: Esta função é chamada pelo modal para EXECUTAR a remoção
        async function executeBulkRemove() {
            // 1. Pega os IDs da variável global
            if (videoIdsForBulkRemove.length === 0) {
                showNotification('Erro: Nenhum vídeo selecionado.', 'error');
                closeBulkRemoveConfirmModal();
                return;
            }

            toggleLoading('bulkRemoveConfirmBtn', true); // Ativa o loading

            // 2. Cria um array de "promessas" de remoção
            let removePromises = [];
            videoIdsForBulkRemove.forEach(id => {
                removePromises.push(videoQueueRef.child(id).remove());
            });

            // 3. Executa todas as remoções em paralelo
            try {
                await Promise.all(removePromises);
                showNotification(`${videoIdsForBulkRemove.length} vídeos removidos com sucesso.`, 'success');
            } catch (error) {
                console.error("Erro ao remover vídeos em lote:", error);
                showNotification('Ocorreu um erro ao remover os vídeos.', 'error');
            } finally {
                toggleLoading('bulkRemoveConfirmBtn', false); // Desativa o loading
                closeBulkRemoveConfirmModal(); // Fecha o modal e limpa o array
            }
        }


        /**
         * Inicializa o player e carrega a fila de vídeos.
         */
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'autoplay': 1,
                    'controls': 1,
                    'modestbranding': 1,
                    'rel': 0,
                    'disablekb': 1
                },
                events: {
                    'onReady': (event) => {

                        player.setVolume(50);
                        loadVideoQueue();

                        // --- INÍCIO DA CORREÇÃO ---
                        console.log('Player está PRONTO.');
                        isPlayerReady = true;
                    
        startSyncHeartbeat();
                        updatePlayerMode();
                        // --- FIM DA CORREÇÃO ---
                    },
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // ======== Controles do overlay ========
        const overlayPlayBtn = document.getElementById('overlayPlayBtn');
        const overlayPlayIcon = document.getElementById('overlayPlayIcon');
        const overlayVolume = document.getElementById('overlayVolume');


        const overlayFullscreenBtn = document.getElementById('overlayFullscreenBtn');


        overlayFullscreenBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFullscreen();
        });

        function toggleFullscreen() {
            const container = document.getElementById('player-container');
            if (!document.fullscreenElement) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }

        }

        function updateOverlayPlayIcon() {
            if (!player || typeof player.getPlayerState !== 'function') return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                overlayPlayIcon.className = 'fas fa-pause';
            } else {
                overlayPlayIcon.className = 'fas fa-play';
            }
        }

        function togglePlayPauseFromOverlay() {
            if (!player) return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
            setTimeout(updateOverlayPlayIcon, 100); // atualiza ícone logo depois
        }

        function setVolumeFromOverlay(value) {
            if (!player || typeof player.setVolume !== 'function') return;
            player.setVolume(Number(value));
            showNotification(`Volume: ${value}%`, 'info');
        }

        // listeners
        overlayPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePlayPauseFromOverlay();
        });

        overlayVolume.addEventListener('input', (e) => {
            e.stopPropagation();
            setVolumeFromOverlay(e.target.value);
        });



        function handleClearQueue() {
            // (Se é Admin OU se tem 1 ou 0 pessoas na sala)
            if (isAdminLoggedIn || onlineUserCount <= 1) {
                console.log('Modo Solo/Admin: Limpando fila direto...');
                
                // Pergunta de segurança simples (sem senha)
                if (confirm('Tem certeza que deseja limpar toda a fila?')) {
                    executeClearQueue();
                }
            } else {
                // Se tiver mais gente e não for admin, pede senha
                console.log('Modo Festa: Pedindo senha...');
                openModal();
            }
        }

        /**
         * Abre o modal para limpar a fila.
         */
        function openModal() {
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('adminName').focus();
        }

        /**
         * Fecha o modal para limpar a fila e limpa os campos.
         */
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
            document.getElementById('adminName').value = '';
            document.getElementById('clearPassword').value = '';
        }

        /**
         * Abre o modal para remover um vídeo específico.
         * @param {string} id - O ID (chave do Firebase) do vídeo a ser removido.
         */
        function openRemoveModalWithId(id) {
            videoToRemoveId = id; // Armazena o ID do Firebase key, que é uma string
            document.getElementById('removeModal').style.display = 'flex';
            document.getElementById('removeAdminName').focus();
        }

        /**
         * Fecha o modal para remover um vídeo e limpa os campos.
         */
        function closeRemoveModal() {
            document.getElementById('removeModal').style.display = 'none';
            document.getElementById('removeAdminName').value = '';
            document.getElementById('removePassword').value = '';
            videoToRemoveId = null; // Reseta o ID do vídeo a ser removido
        }

        /**
          * Lógica central para limpar a fila (sem autenticação).
          * Remove todos os vídeos da fila.
          * @returns {Promise<boolean>} - Retorna 'true' se foi bem-sucedido, 'false' se falhou.
          */
        async function executeClearQueue() {
            try {
                await videoQueueRef.remove();
                showNotification('Fila limpa com sucesso!', 'success');
                closeModal(); 
            } catch (error) {
                console.error('Erro ao limpar fila:', error);
                showNotification('Erro ao limpar a fila.', 'error');
            }
        }

        /**
         * Limpa toda a fila de vídeos no Firebase Realtime Database.
         * Requer credenciais de administrador (chamado pelo modal).
         */
        async function clearQueue() {
            const adminEmail = document.getElementById('adminName').value.trim();
            const password = document.getElementById('clearPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha todos os campos.', 'error');
                return;
            }

            toggleLoading('clearQueueBtn', true);

            try {
                // 1. Tenta autenticar
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // 2. Se autenticou, executa a lógica de limpar
                const success = await executeClearQueue();

                // 3. Se foi bem-sucedido, fecha o modal
                if (success) {
                    closeModal();
                }

            } catch (error) {
                console.error('Erro de autenticação ou ao limpar fila:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    showNotification('Erro ao limpar a fila. Verifique a conexão.', 'error');
                }
            } finally {
                toggleLoading('clearQueueBtn', false);
            }
        }

        /**
         * Remove um vídeo específico da fila no Firebase Realtime Database.
         * Requer credenciais de administrador.
         */
        async function removeVideo() {
            const adminEmail = document.getElementById('removeAdminName').value.trim();
            const password = document.getElementById('removePassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha todos os campos.', 'error');
                return;
            }

            if (videoToRemoveId === null) {
                showNotification('Nenhum vídeo selecionado para remoção.', 'error');
                return;
            }

            toggleLoading('removeVideoBtn', true);

            try {
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);
                await videoQueueRef.child(videoToRemoveId).remove();
                showNotification('Vídeo removido com sucesso!', 'success');
                closeRemoveModal();
            } catch (error) {
                console.error('Erro de autenticação ou ao remover vídeo:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    showNotification('Erro ao remover o vídeo. Verifique a conexão.', 'error');
                }
            } finally {
                toggleLoading('removeVideoBtn', false);
            }
        }

        function handleRemoveVideo(id) {
            // Usa a variável global que já temos
            if (isAdminLoggedIn || onlineUserCount <= 1) {
                // Modo Solo ou Admin: Remove sem perguntar
                executeRemoveVideo(id);
            } else {
                // Modo Festa: Abre o modal de senha
                openRemoveModalWithId(id);
            }
        }

        /**
         * NOVO: Executa a remoção direta (sem modal).
         */
        async function executeRemoveVideo(id) {
            try {
                await videoQueueRef.child(id).remove();
                showNotification('Vídeo removido!', 'success');
            } catch (error) {
                console.error('Erro ao remover vídeo:', error);
                showNotification('Erro ao remover vídeo.', 'error');
            }
        }

        // Event listeners para alternar a visibilidade da senha nos modais
        document.getElementById('togglePassword').addEventListener('click', function () {
            const passwordField = document.getElementById('clearPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        document.getElementById('toggleRemovePassword').addEventListener('click', function () {
            const passwordField = document.getElementById('removePassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        // Fecha os modais se o usuário clicar fora do conteúdo do modal
        window.addEventListener('click', function (event) {
            if (event.target.classList.contains('modal')) {
                closeModal();
                closeRemoveModal();
                closeYTSearchModal();
                closeEditNameModal();
                closeNextVideoModal();
                closeAdminUnlockModal();
                closeBulkRemoveConfirmModal();
                closePanelModal();
                closeDeleteAllRoomsModal();

            }
        });

        // Fecha os modais se o usuário pressionar a tecla 'Escape'
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                closeModal();
                closeRemoveModal();
                closeYTSearchModal();
                closeEditNameModal();
                closeNextVideoModal();
                closeAdminUnlockModal();
                closeBulkRemoveConfirmModal();
                closePanelModal();
                closeDeleteAllRoomsModal();
            }
        });

        // =================================================================
        // SINCRONIZAÇÃO DE RECEBIMENTO (CLIENTES)
        // =================================================================
        
        let isSeeking = false; // Para evitar loop infinito de updates

        // Ouve mudanças no estado do player
        playerStateRef.on('value', (snapshot) => {
            // Se eu sou Admin ou estou sozinho, EU sou a fonte da verdade. Ignoro atualizações.
            if (isAdminLoggedIn || isBroadcaster) return;
            
            // Se o player não estiver pronto, não faz nada
            if (!player || typeof player.seekTo !== 'function') return;

            const state = snapshot.val();
            if (!state) return;

            // Calcula o tempo real atual
            // Fórmula: TempoDoVideoOriginal + (HoraAtual - HoraDaAtualização)
            // Ex: Estava em 10s quando atualizou há 5s atrás -> Agora deve estar em 15s.
            const now = Date.now();
            // Precisamos estimar o offset do servidor (approximado) ou usar o tempo local se o skew for pequeno.
            // Para simplificar, assumimos clocks sincronizados ou usamos a diferença direta se o update for recente.
            
            // Se estiver tocando, compensamos o lag
            let targetTime = state.videoTime;
            if (state.status === 'playing') {
                 // Convertendo timestamp do firebase (aprox) para local
                 // Nota: Firebase timestamp é ms. VideoTime é segundos.
                 const timePassedSeconds = (now - state.timestamp) / 1000; 
                 targetTime += timePassedSeconds;
            }

            // Verifica se meu player está muito desincronizado (> 2 segundos)
            const myTime = player.getCurrentTime();
            const diff = Math.abs(myTime - targetTime);

            if (diff > 2 && !isSeeking) {
                console.log(`Sincronizando: Meu tempo ${myTime.toFixed(1)} -> Alvo ${targetTime.toFixed(1)}`);
                isSeeking = true;
                player.seekTo(targetTime, true);
                setTimeout(() => { isSeeking = false; }, 1000); // Trava breve
            }

            // Sincroniza Play/Pause
            const myState = player.getPlayerState();
            if (state.status === 'playing' && myState !== YT.PlayerState.PLAYING) {
                player.playVideo();
            } else if (state.status === 'paused' && myState !== YT.PlayerState.PAUSED) {
                player.pauseVideo();
            }
        });

        // ====================================================================
        // Funções do Chat (Integradas)
        // ====================================================================

        /**
         * Inicializa os listeners do chat.
         */
        function initializeChatFunctions() {
            loadChatMessages();
            setupTypingListeners();
        }

        /**
         * Carrega as mensagens do chat e ouve por novas.
         */
        function loadChatMessages() {
            chatMessagesRef.orderByChild('timestamp').limitToLast(50).on('value', (snapshot) => {
                const messages = snapshot.val() || {};
                displayMessages(messages);
            });
        }

        /**
         * Configura os listeners de "digitando".
         */
        function setupTypingListeners() {
            chatTypingRef.on('value', (snapshot) => {
                const typingUsers = snapshot.val() || {};
                updateTypingIndicator(typingUsers);
            });
        }

        /**
         * Envia a mensagem do chat para o Firebase.
         */
        function sendChatMessage() {
            const messageInput = document.getElementById('chatMessageInput');
            const messageText = messageInput.value.trim();

            if (messageText === '') return;

            // Pega o nome do usuário da sessão (do index.html)
            const userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

            // Para o indicador de "digitando"
            stopTyping();

            // --- MODIFICAÇÃO AQUI ---
            // Cria a mensagem base
            const messageData = {
                userId: userVoteId, // Reutiliza o ID único do sistema de votação
                userName: userName,
                userIsAdmin: isAdminLoggedIn, // Reutiliza a variável global de admin
                text: messageText,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            // Adiciona dados de resposta, se houver
            if (currentReplyMessage) {
                messageData.replyToId = currentReplyMessage.id;
                messageData.replyToUser = currentReplyMessage.user;
                messageData.replyToText = currentReplyMessage.text;
            }

            // Salva no Firebase
            chatMessagesRef.push(messageData)
                .then(() => {
                    messageInput.value = ''; // Limpa o campo
                    cancelReply(); // <-- LIMPA O CONTEXTO DE RESPOSTA
                })
                .catch((error) => {
                    console.error('Erro ao enviar mensagem:', error);
                    showNotification('Erro ao enviar mensagem', 'error');
                });
        }

        // Editar emsnagem
        function showEditUI(messageKey, base64Text) {
            try {
                // 1. Decodifica o texto original (seguro para UTF-8)
                const rawText = decodeURIComponent(escape(atob(base64Text)));

                // 2. Pega todos os elementos da mensagem
                const textElement = document.getElementById(`text-${messageKey}`);
                const editContainer = document.getElementById(`edit-container-${messageKey}`);
                const actionsContainer = document.getElementById(`actions-${messageKey}`);
                const editInput = editContainer.querySelector('.chat-edit-input');

                // 3. Esconde o texto e os botões de ação
                textElement.style.display = 'none';
                actionsContainer.style.display = 'none';

                // 4. Mostra a caixa de edição
                editContainer.style.display = 'block';

                // 5. Preenche o textarea com o texto original e foca nele
                editInput.value = rawText;
                editInput.focus();

                // Auto-ajusta a altura do textarea (bônus)
                editInput.style.height = 'auto';
                editInput.style.height = (editInput.scrollHeight) + 'px';

            } catch (e) {
                console.error("Erro ao decodificar texto para edição:", e);
                showNotification('Erro ao tentar editar a mensagem.', 'error');
            }
        }

        /**
         * NOVO: Cancela a edição e reverte a UI.
         */
        function cancelEdit(messageKey) {
            // 1. Pega todos os elementos
            const textElement = document.getElementById(`text-${messageKey}`);
            const editContainer = document.getElementById(`edit-container-${messageKey}`);
            const actionsContainer = document.getElementById(`actions-${messageKey}`);

            // 2. Esconde a caixa de edição
            editContainer.style.display = 'none';

            // 3. Mostra o texto original e os botões de ação novamente
            textElement.style.display = 'block';
            actionsContainer.style.display = 'flex'; // 'flex' ou 'block'
        }

        /**
         * NOVO: Salva a mensagem editada no Firebase.
         */
        async function saveEdit(messageKey) {
            // 1. Pega o novo texto do textarea
            const editInput = document.getElementById(`edit-container-${messageKey}`).querySelector('.chat-edit-input');
            const newText = editInput.value.trim();

            if (!newText) {
                showNotification('A mensagem não pode ficar vazia.', 'error');
                return;
            }

            try {
                // 2. Atualiza a mensagem no Firebase
                await chatMessagesRef.child(messageKey).update({
                    text: newText,
                    isEdited: true, // Marca a mensagem como editada
                    lastEdited: firebase.database.ServerValue.TIMESTAMP // (Opcional)
                });

                showNotification('Mensagem atualizada!', 'success');
                // A UI vai se atualizar sozinha por causa do listener 'on("value")',
                // mas chamamos cancelEdit() para esconder a caixa imediatamente.
                cancelEdit(messageKey);

            } catch (error) {
                console.error("Erro ao salvar edição:", error);
                showNotification('Erro ao salvar. Tente novamente.', 'error');
            }
        }
        /**
         * Lida com a tecla Enter no input do chat.
         */
        function handleChatInput(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            } else {
                startTyping(); // Inicia indicador de digitação
            }
        }

        /**
         * Informa ao Firebase que o usuário está digitando.
         */
        function startTyping() {
            const userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

            if (!isTyping) {
                isTyping = true;
                chatTypingRef.child(userVoteId).set({
                    name: userName,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // Reinicia o timeout
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(stopTyping, 3000);
        }

        /**
         * Informa ao Firebase que o usuário parou de digitar.
         */
        function stopTyping() {
            if (isTyping) {
                isTyping = false;
                chatTypingRef.child(userVoteId).remove();
            }
            clearTimeout(typingTimeout);
        }

        /**
         * Mostra quem está digitando.
         */
        function updateTypingIndicator(typingUsers) {
            const typingIndicator = document.getElementById('typingIndicator');
            const typingUserSpan = document.getElementById('typingUser');

            const now = Date.now();
            const activeTypers = Object.entries(typingUsers)
                .filter(([userId, data]) => {
                    if (userId === userVoteId) return false; // Não mostrar a si mesmo
                    return (now - (data.timestamp || 0)) < 3000;
                })
                .map(([_, data]) => data.name);

            if (activeTypers.length > 0) {
                typingUserSpan.textContent = activeTypers.join(', ');
                typingIndicator.classList.add('active');
            } else {
                typingIndicator.classList.remove('active');
            }
        }

        /**
         * Renderiza as mensagens na tela.
         */
        function displayMessages(messages) {
            const chatContainer = document.getElementById('chatMessages');
            const emptyChat = chatContainer.querySelector('.empty-chat');

            if (Object.keys(messages).length > 0 && emptyChat) {
                emptyChat.remove();
            }

            const typingIndicator = document.getElementById('typingIndicator');
            chatContainer.innerHTML = ''; // Limpa o chat
            if (typingIndicator) {
                chatContainer.appendChild(typingIndicator); // Readiciona o indicador
            }

            // --- MODIFICAÇÃO AQUI ---
            // Itera sobre as CHAVES (keys) do objeto, não só os valores
            // O "orderByChild" do Firebase já garante a ordem
            Object.keys(messages).forEach(key => {
                const message = messages[key];
                // Passa a CHAVE (ID) e o objeto da mensagem
                const messageElement = createMessageElement(key, message);
                chatContainer.appendChild(messageElement);
            });

            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function getUserColor(str) {
            if (!str || str === 'Visitante') return 'hsl(0, 0%, 70%)'; // Cor padrão para 'Visitante'

            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = hash % 360; // 0 a 360
            const saturation = 70; // Fixo: 70% (bom e colorido)
            const lightness = 65;  // Fixo: 65% (claro, bom em fundo escuro)

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        /**
     * Cria o elemento HTML para uma única mensagem (ESTILO BOLHA). (MODIFICADA)
     * @param {string} messageKey - O ID (chave) da mensagem no Firebase.
     * @param {object} message - O objeto da mensagem.
     */
        function createMessageElement(messageKey, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message';
            messageElement.id = 'msg-' + messageKey; // ID para o scroll

            // Verifica se é "minha"
            const isMine = (message.userId === userVoteId);
            if (isMine) {
                messageElement.classList.add('mine');
            }

            if (message.userIsAdmin) {
                messageElement.classList.add('admin');
            }
            if (message.isSystem) {
                messageElement.classList.add('system');
            }

            // Sanitização
            const safeText = (message.text || '')
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            const safeUser = (message.userName || 'Visitante')
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            // --- LÓGICA DE COR ---
            let userColorStyle = '';
            if (!message.userIsAdmin && !message.isSystem) {
                const color = getUserColor(message.userName);
                userColorStyle = `style="color: ${color}"`;
            }

            // --- 1. Bloco de Resposta (Se esta MENSAGEM é uma resposta) ---
            let replyHtml = '';
            if (message.replyToId) {
                const safeReplyText = (message.replyToText || '')
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
                const safeReplyUser = (message.replyToUser || 'Alguém')
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

                replyHtml = `
        <div class="chat-reply-block" onclick="scrollToMessage('${message.replyToId}')">
            <div class="chat-reply-block-user">${safeReplyUser}</div>
            <div class="chat-reply-block-text">${safeReplyText}</div>
        </div>
        `;
            }

            // --- 2. Botão de Resposta (Para RESPONDER a esta mensagem) ---
            let snippet = safeText.length > 40 ? safeText.substring(0, 40) + '...' : safeText;
            snippet = snippet.replace(/'/g, "\\'").replace(/"/g, "&quot;").replace(/\n/g, " ");

            const replyBtnHtml = `
        <button class="chat-reply-btn" title="Responder" onclick="setReplyContext('${messageKey}', '${safeUser}', '${snippet}')">
            <i class="fas fa-reply"></i>
        </button>
    `;

            // --- 3. Montagem Final ---
            const timeString = formatTime(message.timestamp);

            const safeBase64Text = btoa(unescape(encodeURIComponent(message.text || '')));

            // --- INÍCIO DA MUDANÇA ---
            messageElement.innerHTML = `
        ${replyHtml} 
        <div class="chat-message-header">
            <div class="chat-user ${message.userIsAdmin ? 'admin-badge' : ''}" ${userColorStyle}>
                ${message.userIsAdmin ? '<i class="fas fa-crown"></i>' : ''}
                ${safeUser}
            </div>
            
            <div class="chat-message-actions" id="actions-${messageKey}">
                ${replyBtnHtml} 
                
                ${isMine ? `<button class="chat-edit-btn" title="Editar" onclick="showEditUI('${messageKey}', '${safeBase64Text}')">
                                <i class="fas fa-pencil-alt"></i>
                            </button>` : ''} 
            </div>
            </div>

        <div class="chat-text" id="text-${messageKey}">${safeText}</div>

       <div class="chat-edit-container" id="edit-container-${messageKey}" style="display: none; margin-top: 10px;">
    
    <textarea class="chat-edit-input" style="
        width: 100%;
        min-height: 60px;
        padding: 10px 12px;
        background: var(--dark-2);
        border: 1px solid var(--dark-4);
        border-radius: 8px;
        color: var(--text-primary);
        font-family: 'Poppins', sans-serif;
        font-size: 0.9rem;
        resize: vertical;
        outline: none;
        line-height: 1.4;
    " onfocus="this.style.borderColor='var(--primary-color)'; this.style.background='var(--dark-1)'" 
    onblur="this.style.borderColor='var(--dark-4)'; this.style.background='var(--dark-2)'"></textarea>
    
    <div class="chat-edit-actions" style="
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 8px;
    ">
        
        <button class="btn small danger" onclick="cancelEdit('${messageKey}')" style="
            background: var(--danger-color); /* <-- CORRIGIDO: era --error-color */
            border: 1px solid var(--danger-color); /* <-- CORRIGIDO: era --error-color */
            color: white;
            padding: 6px 16px; /* <-- CORRIGIDO: era 12px */
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        " onmouseover="this.style.background='#b71c1c'" 
        onmouseout="this.style.background='var(--danger-color)'">
            Cancelar
        </button>
        
        <button class="btn small primary" onclick="saveEdit('${messageKey}')" style="
            background: transparent; /* <-- MUDADO */
            border: 1px solid var(--primary-color);
            color: var(--primary-color); /* <-- MUDADO */
            padding: 6px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        " onmouseover="this.style.background='var(--primary-color)'; this.style.color='white'" 
        onmouseout="this.style.background='transparent'; this.style.color='var(--primary-color)'">
            Salvar
        </button>

    </div>
</div>

        <div class="chat-time">
            ${timeString}
            ${message.isEdited ? '<span class="edited-marker"> (editado)</span>' : ''}
        </div>

        `;
            // --- FIM DA MUDANÇA ---

            return messageElement;
        }

        /**
         * Formata o timestamp para exibição.
         */
        function formatTime(timestamp) {
            if (!timestamp) return '';
            const messageTime = new Date(timestamp);
            const now = new Date();

            if (now.toDateString() === messageTime.toDateString()) {
                return messageTime.toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            return messageTime.toLocaleDateString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // ====================================================================
        // Fim das Funções do Chat
        // ====================================================================
        // Efeito de fade-in na carga da página
        document.addEventListener('DOMContentLoaded', function () {
            document.body.style.opacity = '0';
            setTimeout(() => {
                document.body.style.transition = 'opacity 0.5s ease';
                document.body.style.opacity = '1';
            }, 100);
        });

        // Variáveis para o sistema de votação
        let currentSongRef = null;
        let votesRef = null;
        let userVoteId = null;
        // ====================================================================
        // Variáveis do Chat (Integrado)
        // ====================================================================
        const chatMessagesRef = roomRef.child('chat/messages');
        const chatTypingRef = roomRef.child('chat/typing');
        let isTyping = false;
        let typingTimeout;
        let currentReplyMessage = null;
        let onlineUsersCount = 0;

        // Calcula votos necessários baseado em usuários online
        function calculateVotesNeeded() {
            // Se há poucos usuários, precisa da maioria
            if (onlineUsersCount <= 2) return 2;
            if (onlineUsersCount <= 5) return Math.ceil(onlineUsersCount * 0.6); // 60%
            return Math.ceil(onlineUsersCount * 0.5); // 50% para salas maiores
        }

        // Inicializa o chat
        initializeChatFunctions();
        // Inicializa o sistema de votação
        function initializeVotingSystem() {
            currentSongRef = roomRef.child('currentSong');
            votesRef = roomRef.child('currentSong/votes');

            // Gera um ID único para este usuário
            userVoteId = sessionStorage.getItem('userVoteId') || generateUserId();
            sessionStorage.setItem('userVoteId', userVoteId);

            // Monitora número de usuários online
            presenceRef.on('value', (snap) => {
                onlineUsersCount = snap.numChildren();
                updateVotesNeededDisplay();
            });

            // Monitora mudanças na votação
            votesRef.on('value', (snapshot) => {
                updateVoteDisplay(snapshot.val());
            });

            // Reseta votos quando a música muda
            videoQueueRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const firstVideo = Object.values(data)[0];
                    if (firstVideo) {
                        const videoId = extractVideoId(firstVideo.videoUrl);
                        resetVotesForNewSong(videoId);
                    }
                } else {
                    // Fila vazia - reseta votos
                    resetVotes();
                }
            });
        }

        // Atualiza a exibição dos votos necessários
        function updateVotesNeededDisplay() {
            const votesNeeded = calculateVotesNeeded();
            const votesNeededElement = document.getElementById('votesNeeded');
            if (votesNeededElement) {
                votesNeededElement.textContent = votesNeeded;
            }
        }

        // Atualiza a exibição dos votos no botão
        function updateVoteDisplay(votes) {
            const voteCountElement = document.getElementById('voteCount');
            const votesNeededElement = document.getElementById('votesNeeded');
            const skipVoteBtn = document.getElementById('skipVoteBtn');
            const skipVoteBtnText = document.getElementById('skipVoteBtnText');

            if (!votes) {
                voteCountElement.textContent = '0';
                updateVotesNeededDisplay();
                skipVoteBtnText.textContent = 'Votar para Pular';
                skipVoteBtn.disabled = false;
                skipVoteBtn.classList.remove('voted');
                return;
            }

            const voteCount = Object.keys(votes).length;
            const votesNeeded = calculateVotesNeeded();

            voteCountElement.textContent = voteCount;
            votesNeededElement.textContent = votesNeeded;

            // Verifica se o usuário atual já votou
            const hasVoted = votes[userVoteId] !== undefined;

            if (hasVoted) {
                skipVoteBtnText.textContent = 'Você Votou';
                skipVoteBtn.disabled = true;
                skipVoteBtn.classList.add('voted');
            } else {
                skipVoteBtnText.textContent = 'Votar para Pular';
                skipVoteBtn.disabled = false;
                skipVoteBtn.classList.remove('voted');
            }

            // Se atingiu o limite de votos, pula a música
            if (voteCount >= votesNeeded) {
                skipSongByVote();
            }
        }

        // Função principal de votação
        function castVoteToSkip() {
            if (!userVoteId) {
                showNotification('Erro: Sistema de votação não inicializado', 'error');
                return;
            }

            // Verifica se há vídeos na fila
            if (videoQueue.length === 0) {
                showNotification('Não há músicas na fila para pular', 'info');
                return;
            }

            // Verifica se há usuários suficientes online
            if (onlineUsersCount < 2) {
                showNotification('Não há usuários suficientes online para votação', 'info');
                return;
            }

            toggleLoading('skipVoteBtn', true);

            // Registra o voto
            votesRef.child(userVoteId).set({
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                userName: currentSessionUser || 'Anônimo',
                userId: userVoteId
            })
                .then(() => {
                    showNotification('Seu voto foi registrado!', 'success');
                })
                .catch((error) => {
                    console.error('Erro ao votar:', error);
                    showNotification('Erro ao registrar voto', 'error');
                })
                .finally(() => {
                    toggleLoading('skipVoteBtn', false);
                });
        }

        // Pula a música quando a votação é bem-sucedida
        function skipSongByVote() {
            if (videoQueue.length === 0) return;

            const votesNeeded = calculateVotesNeeded();
            showNotification(`Votação bem-sucedida! (${votesNeeded}/${votesNeeded} votos) Pulando música...`, 'success');

            // Remove o primeiro vídeo da fila (música atual)
            const firstVideoId = videoQueue[0].id;
            videoQueueRef.child(firstVideoId).remove()
                .then(() => {
                    showNotification('Música pulada por votação popular!', 'success');
                    // Reseta os votos após um delay
                    setTimeout(resetVotes, 1000);
                })
                .catch((error) => {
                    console.error('Erro ao pular música por votação:', error);
                    showNotification('Erro ao pular música', 'error');
                });
        }

        // Reseta os votos para uma nova música
        function resetVotesForNewSong(videoId) {
            if (!currentSongRef) return;

            currentSongRef.set({
                currentVideoId: videoId,
                votes: {},
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                onlineUsersCount: onlineUsersCount
            });
        }

        // Reseta os votos
        function resetVotes() {
            if (votesRef) {
                votesRef.set({});
            }
        }

        // Gera ID único para usuário
        function generateUserId() {
            return 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }

        // Inicializa o sistema de votação quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(initializeVotingSystem, 1000);
        });

        function FuncaoParaAbrirPainel() {
            // 1. Carrega os dados das salas do Firebase
            loadAdminPanelRooms();
            // 2. Abre o modal
            document.getElementById('panelModal').style.display = 'flex';
        }

        /**
         * Fecha o modal do Painel de Controle Admin.
         */
        function closePanelModal() {
            document.getElementById('panelModal').style.display = 'none';
        }
        // ====================================================================
        // Funções de Resposta do Chat (NOVAS)
        // ====================================================================

        /**
         * Prepara o contexto de resposta
         * (messageKey é o ID do firebase)
         * (userName é o nome do autor original)
         * (messageText é o texto original)
         */
        function setReplyContext(messageKey, userName, messageText) {
            currentReplyMessage = {
                id: messageKey,
                user: userName,
                text: messageText
            };

            // Pega a barra de ações principal
            const actionsBar = document.getElementById('chatActionsBar');
            const contextBox = document.getElementById('chatReplyContext');

            contextBox.querySelector('.chat-reply-user').textContent = `Respondendo a ${userName}`;
            contextBox.querySelector('.chat-reply-text').textContent = messageText;

            // Mostra AMBOS (o contêiner e o conteúdo)
            contextBox.style.display = 'flex';
            actionsBar.style.display = 'block'; // <-- ESTA LINHA É NOVA

            document.getElementById('chatMessageInput').focus();
        }

        /**
         * Cancela a resposta
         */
        function cancelReply() {
            currentReplyMessage = null;

            // Pega a barra de ações principal
            const actionsBar = document.getElementById('chatActionsBar');
            const contextBox = document.getElementById('chatReplyContext');

            // Esconde AMBOS
            contextBox.style.display = 'none';
            actionsBar.style.display = 'none'; // <-- ESTA LINHA É NOVA
        }

        /**
         * Rola a tela até a mensagem original
         */
        function scrollToMessage(messageKey) {
            const element = document.getElementById('msg-' + messageKey);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Adiciona um destaque temporário
                element.classList.remove('message-highlighted'); // Remove
                void element.offsetWidth; // "Reflow" para forçar a animação
                element.classList.add('message-highlighted'); // Adiciona
            } else {
                showNotification('Mensagem original não encontrada (pode estar muito antiga)', 'info');
            }
        }

        /**
         * Limpa TODO o histórico do chat. (Função de Admin)
         */
        async function handleClearChat() {
            // Dupla verificação de segurança
            if (!isAdminLoggedIn) {
                showNotification('Apenas administradores podem limpar o chat.', 'error');
                return;
            }

            // Confirmação final
            if (!confirm('Tem certeza que deseja apagar TODO o histórico do chat para TODOS os usuários? Esta ação não pode ser desfeita.')) {
                return;
            }

            console.log('Admin limpando o chat...');
            try {
                // 1. Remove todas as mensagens do Firebase
                await chatMessagesRef.remove();

                // 2. (Opcional) Adiciona uma mensagem de "Chat limpo"
                await chatMessagesRef.push({
                    userId: 'system',
                    userName: 'Sistema',
                    text: 'O histórico do chat foi limpo por um administrador.',
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    isSystem: true // Marca como mensagem de sistema
                });

                showNotification('Histórico do chat foi limpo com sucesso!', 'success');

            } catch (error) {
                console.error('Erro ao limpar o chat:', error);
                showNotification('Erro ao limpar o chat. Verifique as regras do Firebase.', 'error');
            }
        }

        /**
 * Carrega as salas ativas no painel de admin.
 */
        async function loadAdminPanelRooms() {
            const listElement = document.getElementById('adminRoomList');
            const loaderElement = document.getElementById('adminRoomLoader');

            if (!listElement || !loaderElement) {
                console.error('Elementos do painel admin não encontrados.');
                return;
            }

            listElement.innerHTML = ''; // Limpa a lista antiga
            loaderElement.style.display = 'block'; // Mostra o loader

            try {
                // 1. Referência para o nó principal 'rooms'
                const roomsRef = database.ref('rooms');

                // 2. Busca os dados UMA VEZ
                const snapshot = await roomsRef.once('value');
                const roomsData = snapshot.val();

                if (!roomsData) {
                    // Se não houver salas, mostra mensagem
                    loaderElement.innerHTML = '<div class="empty-yt"><i class="fas fa-ghost"></i><p>Nenhuma sala ativa encontrada.</p></div>';
                    return;
                }

                const roomIds = Object.keys(roomsData);
                let htmlToRender = '';

                // 3. Itera por cada sala encontrada
                roomIds.forEach(roomId => {
                    const room = roomsData[roomId];

                    // Valores padrão com fallbacks robustos
                    const roomName = room.roomName?.trim() || 'Sala sem nome';
                    const creatorName = room.creatorName?.trim() || 'Desconhecido';

                    // Contagem de usuários online
                    const presenceData = room.presence || {};
                    const userCountInRoom = Object.keys(presenceData).length;

                    // Contagem de vídeos na fila
                    const queueData = room.videoQueue || {};
                    const queueCount = Object.keys(queueData).length;

                    // Formatação de data com tratamento de erro
                    let createdAt = 'Data desconhecida';
                    let timeAgo = '';
                    if (room.createdAt) {
                        try {
                            const createdDate = new Date(room.createdAt);
                            if (!isNaN(createdDate.getTime())) {
                                createdAt = createdDate.toLocaleString('pt-BR', {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric',
                                    hour: '2-digit',
                                    minute: '2-digit'
                                });

                                // Calcula há quanto tempo foi criada
                                timeAgo = getTimeAgo(createdDate);
                            }
                        } catch (e) {
                            console.warn(`Erro ao formatar data da sala ${roomId}:`, e);
                        }
                    }

                    // Determina cor baseada na atividade
                    const activityLevel = getActivityLevel(userCountInRoom, queueCount);

                    // 4. Cria o HTML para o item
                    htmlToRender += `
<div class="admin-room-item" data-room-id="${roomId}" data-activity="${activityLevel}">
    <div class="room-header">
        <div class="room-title-section">
            <h4 class="room-name">${escapeHtml(roomName)}</h4>
            <div class="room-meta">
                <span class="room-id">ID: ${roomId}</span>
                ${timeAgo ? `<span class="time-ago">• ${timeAgo}</span>` : ''}
            </div>
        </div>
        <div class="room-stats">
            <div class="stat-badge users-online">
                <i class="fas fa-users"></i>
                <span class="stat-count">${userCountInRoom}</span>
                <span class="stat-label">online</span>
            </div>
            <div class="stat-badge videos-queue">
                <i class="fas fa-list-ol"></i>
                <span class="stat-count">${queueCount}</span>
                <span class="stat-label">vídeos</span>
            </div>
        </div>
    </div>
    
    <div class="room-details">
        <div class="detail-item">
            <i class="fas fa-crown"></i>
            <span class="detail-label">Criador:</span>
            <span class="creator-name">${escapeHtml(creatorName)}</span>
        </div>
        
        <div class="detail-item">
            <i class="fas fa-calendar"></i>
            <span class="detail-label">Criada em:</span>
            <span class="created-date">${createdAt}</span>
        </div>
    </div>

    <div class="room-actions">
        <button class="btn small secondary" onclick="goToRoom('${roomId}')" 
                title="Abrir sala em nova aba">
            <i class="fas fa-eye"></i> Ver Sala
        </button>
        <button class="btn small danger" onclick="deleteRoom('${roomId}')" 
                title="Deletar sala permanentemente">
            <i class="fas fa-trash"></i> Deletar
        </button>
    </div>
</div>
`;
                });

                // Funções auxiliares para melhorar a exibição
                function getTimeAgo(date) {
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);

                    if (diffMins < 1) return 'Agora mesmo';
                    if (diffMins < 60) return `Há ${diffMins} min`;
                    if (diffHours < 24) return `Há ${diffHours} h`;
                    if (diffDays === 1) return 'Ontem';
                    if (diffDays < 7) return `Há ${diffDays} dias`;
                    if (diffDays < 30) return `Há ${Math.floor(diffDays / 7)} sem`;
                    return `Há ${Math.floor(diffDays / 30)} mes`;
                }

                function getActivityLevel(userCount, queueCount) {
                    if (userCount > 5 || queueCount > 10) return 'high';
                    if (userCount > 2 || queueCount > 5) return 'medium';
                    if (userCount > 0 || queueCount > 0) return 'low';
                    return 'inactive';
                }

                function formatLastActivity(timestamp) {
                    try {
                        const activityDate = new Date(timestamp);
                        const now = new Date();
                        const diffHours = Math.floor((now - activityDate) / 3600000);

                        if (diffHours < 1) return 'Menos de 1 hora';
                        if (diffHours === 1) return '1 hora atrás';
                        if (diffHours < 24) return `${diffHours} horas atrás`;
                        if (diffHours < 48) return 'Ontem';
                        return `${Math.floor(diffHours / 24)} dias atrás`;
                    } catch (e) {
                        return 'Desconhecido';
                    }
                }

                function escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                }

                listElement.innerHTML = htmlToRender;
                loaderElement.style.display = 'none'; // Esconde o loader

            } catch (error) {
                console.error('Erro ao carregar salas:', error);
                loaderElement.innerHTML = '<div class="error-yt"><i class="fas fa-exclamation-triangle"></i><p>Erro ao carregar salas.</p></div>';
            }
        }

        /**
         * (Função Auxiliar) Redireciona o admin para a sala selecionada.
         */
        function goToRoom(roomId) {
            if (!roomId) return;
            // Abre a sala (index.html) em uma nova aba com o ID da sala
            window.open(`index.html?room=${roomId}`, '_blank');
        }

        /**
         * (Função Auxiliar) Deleta uma sala do Firebase.
         */
        async function deleteRoom(roomId) {
            if (!roomId) return;

            // Pega o nome da sala pelo HMTL para a confirmação
            const roomElement = document.querySelector(`.admin-room-item[data-room-id="${roomId}"]`);

            // --- CORREÇÃO AQUI ---
            // O código estava procurando 'strong', mas o nome está em 'h4.room-name'
            const roomNameElement = roomElement ? roomElement.querySelector('.room-name') : null;
            const roomName = roomNameElement ? roomNameElement.textContent : 'Sala';
            // --- FIM DA CORREÇÃO ---

            if (confirm(`Tem certeza que deseja deletar a sala "${roomName}"? \n\nID: ${roomId}\n\nISSO É IRREVERSÍVEL E VAI APAGAR TODA A FILA E CHAT DELA.`)) {
                try {
                    // Remove a sala inteira do Firebase
                    await database.ref(`rooms/${roomId}`).remove();

                    showNotification(`Sala "${roomName}" deletada com sucesso.`, 'success');

                    // Remove o item da lista na tela
                    if (roomElement) {
                        roomElement.style.transition = 'all 0.3s ease';
                        roomElement.style.opacity = '0';
                        roomElement.style.transform = 'translateX(-20px)';
                        setTimeout(() => roomElement.remove(), 300);
                    }

                } catch (error) {
                    console.error('Erro ao deletar sala:', error);
                    showNotification('Erro ao deletar sala.', 'error');
                }
            }
        }
        /**
                 * Abre o modal de confirmação para deletar TODAS as salas.
                 */
        function openDeleteAllRoomsModal() {
            document.getElementById('deleteAllRoomsModal').style.display = 'flex';
        }

        /**
         * Fecha o modal de confirmação para deletar TODAS as salas.
         */
        function closeDeleteAllRoomsModal() {
            document.getElementById('deleteAllRoomsModal').style.display = 'none';
        }

        /**
         * Executa a remoção de TODAS as salas do Firebase.
         */
        async function executeDeleteAllRooms() {
            toggleLoading('deleteAllRoomsConfirmBtn', true);

            try {
                const roomsRef = database.ref('rooms'); //

                // 1. Busca o ID de todas as salas (Permitido pela regra ".read" de admin)
                const snapshot = await roomsRef.once('value');
                const roomsData = snapshot.val();

                if (!roomsData) {
                    showNotification('Nenhuma sala para deletar.', 'info');
                    toggleLoading('deleteAllRoomsConfirmBtn', false);
                    closeDeleteAllRoomsModal();
                    return;
                }

                // 2. Cria um array de promessas de exclusão (uma para cada sala)
                const roomIds = Object.keys(roomsData);
                const deletePromises = [];

                roomIds.forEach(roomId => {
                    // Adiciona a promessa de deletar /rooms/ID_DA_SALA
                    // (Permitido pela regra ".write" de admin em /$roomId)
                    deletePromises.push(database.ref(`rooms/${roomId}`).remove());
                });

                // 3. Executa todas as exclusões em paralelo
                await Promise.all(deletePromises);

                showNotification('Todas as salas foram deletadas com sucesso.', 'success');

                loadAdminPanelRooms(); // Atualiza a lista na UI

            } catch (error) {
                //
                console.error('Erro ao deletar todas as salas:', error);
                showNotification('Erro ao deletar salas.', 'error');
            } finally {
                toggleLoading('deleteAllRoomsConfirmBtn', false);
                closeDeleteAllRoomsModal();
            }
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('Service Worker registrado com sucesso:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('Falha ao registrar Service Worker:', error);
                    });
            });
        }

    </script>

  <script>
/* ================================
   ESTADO
================================ */
let sugestaoGeneroSelecionado = 'pop';
let sugestaoTipoSelecionado = 'genero';
let autoSugestaoAtiva = false;
let autoSugestaoInterval = null;
let autoSugestaoCount = 3;

/* ================================
   UI & MODAL
================================ */
function openSugestaoModal() {
  const modal = document.getElementById('sugestaoModal');
  modal.style.display = 'flex';
  switchTab('genero');
  detectarGeneroAtual();
}

function closeSugestaoModal() {
  document.getElementById('sugestaoModal').style.display = 'none';
}

function switchTab(tabName) {
  document.querySelectorAll('.sugestao-tab').forEach(tab => {
    tab.classList.remove('active');
  });

  document.querySelectorAll('.tab-content').forEach(content => {
    content.style.display = 'none';
  });

  const tabBtn = document.querySelector(`.sugestao-tab[onclick="switchTab('${tabName}')"]`);
  const tabContent = document.getElementById(`${tabName}Content`);

  if (tabBtn) tabBtn.classList.add('active');
  if (tabContent) tabContent.style.display = 'block';

  sugestaoTipoSelecionado = tabName;
}

function selectGenero(genero) {
  document.querySelectorAll('.genero-btn').forEach(btn => {
    btn.classList.remove('active');
  });

  const btn = document.querySelector(`.genero-btn[data-genero="${genero}"]`);
  if (btn) btn.classList.add('active');

  sugestaoGeneroSelecionado = genero;
}

function changeAutoCount(change) {
  const el = document.getElementById('autoCount');
  let v = parseInt(el.textContent) + change;
  v = Math.max(1, Math.min(10, v)); // Mínimo 1, Máximo 10
  el.textContent = v;
  autoSugestaoCount = v;
}

/* ================================
   LÓGICA AUXILIAR
================================ */
function detectarGeneroAtual() {
  if (typeof player === 'undefined' || !player || !player.getVideoData) return;
  try {
    const title = (player.getVideoData().title || '').toLowerCase();
    const generosMap = {
      sertanejo: ['sertanejo','modão','marilia','gusttavo'],
      funk: ['funk','trap','dj','mandelão'],
      pop: ['pop','hit','taylor','bruno mars'],
      rock: ['rock','metal','punk'],
      eletronica: ['edm','house','techno','alok'],
      rap: ['rap','hip hop','mc','matue'],
      reggaeton: ['reggaeton','bad bunny','anitta'],
      pagode: ['pagode','samba','ferrugem','thiaguinho']
    };
    for (const genero in generosMap) {
      if (generosMap[genero].some(k => title.includes(k))) {
        selectGenero(genero);
        break;
      }
    }
  } catch {}
}

function gerarQueryAtual() {
  let query = 'top hits 2026';
  
  if (sugestaoTipoSelecionado === 'genero') {
    const map = {
      sertanejo: 'sertanejo 2026 as mais tocadas',
      funk: 'funk hits 2026',
      pop: 'pop internacional 2026 hits',
      rock: 'rock playlist 2026',
      eletronica: 'summer eletrohits 2026',
      rap: 'rap trap brasil 2026',
      reggaeton: 'reggaeton 2026 éxitos',
      pagode: 'pagode churrasco 2026'
    };
    query = map[sugestaoGeneroSelecionado] || query;
  }
  
  if (sugestaoTipoSelecionado === 'tendencia') {
    const arr = ['top 50 brasil', 'viral hits global', 'tiktok music 2026', 'billboard hot 100'];
    query = arr[Math.floor(Math.random() * arr.length)];
  }
  
  if (sugestaoTipoSelecionado === 'similar' && player?.getVideoData) {
    try {
        const t = player.getVideoData().title;
        if (t) query = t.split(' ').slice(0, 3).join(' ') + ' mix';
    } catch(e) {}
  }
  
  return query;
}

/* ================================
   FUNÇÃO ÚNICA: Adicionar Agora
================================ */
async function sugerirAgora() {
  const btn = document.querySelector('.btn-now');
  const original = btn.innerHTML;
  btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Buscando...';
  btn.disabled = true;

  try {
    const query = gerarQueryAtual();
    const res = await fetch(`/api/youtube-search?q=${encodeURIComponent(query)}&maxResults=10`);
    const json = await res.json();

    if (json.items && json.items.length) {
      // Filtro rigoroso: Só aceita vídeos
      const validos = json.items.filter(v => v.id.kind === 'youtube#video');
      
      if (validos.length > 0) {
        const escolhido = validos[Math.floor(Math.random() * validos.length)];
        const url = `https://www.youtube.com/watch?v=${escolhido.id.videoId}`;
        const user = sessionStorage.getItem('ytSessionUser') || '🤖 DJ';
        
        await videoQueueRef.push({ phone: user, videoUrl: url });
        showNotification(`Adicionado: ${escolhido.snippet.title}`, 'success');
        setTimeout(closeSugestaoModal, 500);
      } else {
        showNotification('Nenhum vídeo válido encontrado.', 'info');
      }
    }
  } catch (e) {
    console.error(e);
    showNotification('Erro ao buscar sugestão.', 'error');
  } finally {
    btn.innerHTML = original;
    btn.disabled = false;
  }
}

/* ================================
   LÓGICA PRINCIPAL DO AUTO DJ
================================ */
async function rodarCicloAutoDJ() {
    if (!autoSugestaoAtiva) return;

    // 1. Verifica quantas músicas tem na fila
    const snap = await videoQueueRef.once('value');
    const data = snap.val();
    const len = data ? Object.keys(data).length : 0;

    // Se já temos músicas suficientes, não faz nada
    if (len >= autoSugestaoCount) return;

    const faltam = autoSugestaoCount - len;
    console.log(`AutoDJ: Fila tem ${len}. Meta é ${autoSugestaoCount}. Adicionando ${faltam}...`);

    // 2. Busca músicas em lote (pede 50 para garantir variedade e validade)
    const query = gerarQueryAtual();
    try {
        const res = await fetch(`/api/youtube-search?q=${encodeURIComponent(query)}&maxResults=50`);
        const json = await res.json();

        if (!json.items || !json.items.length) return;

        // 3. FILTRO RIGOROSO (Evita erros de "undefined id")
        let candidatos = json.items.filter(v => {
            const isVideo = v.id.kind === 'youtube#video'; // TEM que ser video
            const t = v.snippet.title.toLowerCase();
            const isClean = !t.includes('live') && !t.includes('ao vivo') && !t.includes('short');
            return isVideo && isClean;
        });

        if (candidatos.length === 0) return;

        // 4. Embaralha
        candidatos.sort(() => Math.random() - 0.5);

        // 5. Adiciona a quantidade necessária
        let adicionados = 0;
        
        // Loop seguro: tenta adicionar até atingir a meta
        for (const video of candidatos) {
            // Se já atingiu a meta, para
            if (adicionados >= faltam) break;

            try {
                const url = `https://www.youtube.com/watch?v=${video.id.videoId}`;
                
                // Adiciona ao Firebase
                await videoQueueRef.push({
                    phone: '🤖 DJ Auto',
                    videoUrl: url
                });
                
                adicionados++;
                
                // Pequeno delay para garantir ordem no banco
                await new Promise(r => setTimeout(r, 200));

            } catch (errInner) {
                // Se der erro em UMA música, loga e continua para a próxima (NÃO QUEBRA O LOOP)
                console.warn("Erro ao adicionar música específica no AutoDJ:", errInner);
            }
        }
        
        if (adicionados > 0) {
            console.log(`AutoDJ finalizou ciclo. Adicionou ${adicionados} músicas.`);
        }

    } catch (err) {
        console.error('Erro crítico no AutoDJ:', err);
    }
}

/* ================================
   CONTROLE DO AUTO DJ (CORRIGIDO)
================================ */

// Função chamada pelo BOTÃO "Auto"
function toggleAutoDjBtn() {
  const toggle = document.getElementById('autoAddToggle');
  // Inverte o estado visual da caixinha
  toggle.checked = !toggle.checked;
  // Chama a lógica principal baseada no novo estado
  ativarAutoSugestao();
}

// Função chamada pelo CHECKBOX (onchange) e pelo BOTÃO
function ativarAutoSugestao() {
  const toggle = document.getElementById('autoAddToggle');

  // Verifica se a caixinha está marcada
  if (toggle.checked) {
    // LIGAR
    if (!autoSugestaoAtiva) {
      autoSugestaoAtiva = true;
      showNotification('Auto-sugestão ligada 🤖', 'success');
      // Inicia imediatamente
      iniciarAutoSugestao();
    }
  } else {
    // DESLIGAR
    autoSugestaoAtiva = false;
    if (autoSugestaoInterval) clearInterval(autoSugestaoInterval);
    showNotification('Auto-sugestão desligada.', 'info');
  }
}

function iniciarAutoSugestao() {
  if (autoSugestaoInterval) clearInterval(autoSugestaoInterval);
  
  // Roda IMEDIATAMENTE a primeira vez (não espera 15s)
  rodarCicloAutoDJ();

  // Configura o intervalo para rodar a cada 15 segundos
  autoSugestaoInterval = setInterval(rodarCicloAutoDJ, 15000);
}

/* ================================
   INIT
================================ */
document.addEventListener('DOMContentLoaded', () => {
  selectGenero('pop');
  switchTab('genero');

  const modal = document.getElementById('sugestaoModal');
  if (modal) {
      modal.addEventListener('click', e => {
        if (e.target === modal) closeSugestaoModal();
      });
  }
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeSugestaoModal();
  });
});
</script>

    <script src="https://www.youtube.com/iframe_api"></script>
    </div>


</body>

</html>