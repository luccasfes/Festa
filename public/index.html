<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <link rel="icon" type="image/x-icon" href="assets/favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowLink</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://www.youtube.com/iframe_api"></script>

    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>

    <link rel="stylesheet" href="style.css">
</head>

<body class="non-admin">
    <div id="particles"></div>
    <div class="container">
        <header class="app-header">
            <div class="header-controls-left">
                <button class="btn small" id="adminUnlockBtn" onclick="openAdminUnlockModal()">
                    <i class="fas fa-lock"></i>
                    <span id="adminStatusText">Admin</span>
                    <span id="adminNameDisplay" style="margin-left: 5px; display: none;"></span>
                </button>

                <button class="btn small" id="panelBtn" onclick="FuncaoParaAbrirPainel()">
                    <i class="fas fa-cog"></i> <span>Painel</span>
                </button>
            </div>
            <h1><i class="fas fa-music"></i> FlowLink<i class="fas fa-headphones"></i></h1>
            <div class="presence-indicator">
                <i class="fas fa-users"></i>
                <span id="userCount">0</span> online
            </div>
        </header>

        <main class="main-layout">
            <section class="input-section card">
                <h2><i class="fas fa-plus-circle"></i> Adicionar Vídeo</h2>
                <div class="input-group">
                    <label for="phone"><i class="fas fa-user"></i> Nome:</label>
                    <input type="text" id="phone" placeholder="Quem adicionou?" required>
                </div>
                <div class="input-group">
                    <label for="videoUrl"><i class="fab fa-youtube"></i> URL do Vídeo:</label>
                    <input type="text" id="videoUrl" placeholder="Link do YouTube" required>
                </div>
                <button class="btn primary" onclick="addVideo()" id="addVideoBtn">
                    <span id="addBtnText">Adicionar à Fila</span>
                    <span id="addBtnLoader" class="loading" style="display: none;"></span>
                </button>
                <button class="btn youtube" onclick="openYTSearchModal()">
                    <i class="fab fa-youtube"></i> Buscar no YouTube
                </button>


            </section>


            <section class="video-player-section card">
                <h2><i class="fas fa-play-circle"></i> Vídeo em Execução</h2>
                <div id="player-container">
                    <div id="videoPlayer"></div>

                    <!-- máscara que bloqueia interações com a barra nativa (continua presente) -->
                    <div id="player-mask"></div>

                    <!-- Controles personalizados (play/pause + volume). Visíveis apenas para non-admin -->
                    <div class="player-overlay-controls" aria-hidden="false">
                        <button id="overlayPlayBtn" title="Play/Pause"><i id="overlayPlayIcon"
                                class="fas fa-play"></i></button>
                        <label for="overlayVolume" style="color:var(--text-secondary);font-size:0.9rem;">Vol</label>
                        <input id="overlayVolume" type="range" min="0" max="100" step="1" value="50"
                            aria-label="Volume">
                        <button id="overlayFullscreenBtn" title="Tela cheia"><i class="fas fa-expand"></i></button>
                    </div>

                </div>


                <div id="currentVideoInfo">
                    <h3>Escolha de: <span id="currentUser">Nenhum vídeo em execução</span></h3>
                    <p class="current-url" id="currentVideoUrl">Nenhuma URL disponível</p>
                </div>
                <button class="btn primary skip-video-button" onclick="handleSkipOrVote()" id="skipVoteBtn">
                    <i class="fas fa-forward"></i>
                    <span id="skipVoteBtnText">Votar para Pular</span>
                    <span id="voteCounterWrapper">
                        (<span id="voteCount">0</span>/<span id="votesNeeded">0</span>)
                    </span>
                    <span id="skipVoteBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </section>

            <section class="queue-section card">
                <h2>
                    <i class="fas fa-list-ol"></i> Fila de Música
                    <button class="btn danger clear-queue-button" onclick="handleClearQueue()">
                        <i class="fas fa-trash-alt"></i> Limpar Fila
                    </button>
                    <button class="btn bulk-remove-button" onclick="removeSelectedVideos()" id="bulkRemoveBtn"
                        style="display: none;">
                        <i class="fas fa-eraser"></i> Remover Selecionados
                    </button>
                </h2>
                <ul id="videoList" class="video-queue-list"></ul>
            </section>
            <section class="chat-section card">
                <h2><i class="fas fa-comments"></i> Chat da Música</h2>
                <button class="btn danger small" onclick="handleClearChat()" id="clearChatBtn" style="display: none;">
                    <i class="fas fa-eraser"></i> Limpar Chat
                </button>
                <div class="chat-users-online">
                    <div class="online-indicator">
                        <div class="online-dot"></div>
                        <span id="onlineCount">1</span> usuário(s) online
                    </div>
                    <div class="user-info">
                        <span id="userNameDisplay">Visitante</span>
                        <button class="btn small secondary" onclick="openYTSearchModal()" style="margin-left: 10px;">
                            <i class="fas fa-edit"></i>
                        </button>
                    </div>
                </div>

                <div id="chatMessages" class="chat-messages-list">
                    <div class="empty-chat">
                        <i class="fas fa-comment-slash"></i>
                        <p>Nenhuma mensagem ainda. Seja o primeiro a comentar!</p>
                    </div>
                </div>

                <div class="typing-indicator" id="typingIndicator">
                    <span id="typingUser"></span> está digitando<span
                        class="typing-dots"><span>.</span><span>.</span><span>.</span></span>
                </div>

                <div class="chat-actions-bar" id="chatActionsBar" style="display: none;">
                    <div class="chat-reply-context" id="chatReplyContext" style="display: none;">
                        <div class="chat-reply-info">
                            <span class="chat-reply-user">Respondendo a...</span>
                            <span class="chat-reply-text"></span>
                        </div>
                        <button class="chat-reply-cancel" onclick="cancelReply()">&times;</button>
                    </div>
                </div>
                <div class="chat-input-group">
                    <input type="text" id="chatMessageInput" placeholder="Digite sua mensagem..."
                        onkeypress="handleChatInput(event)">
                    <button class="btn primary" onclick="sendChatMessage()" title="Enviar">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
                <div class="emoji-picker-container" id="emojiPickerContainer">
            </section>
        </main>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">×</span>
            <h3><i class="fas fa-trash-alt"></i> Limpar Fila</h3>
            <p>Digite seu nome e a senha para limpar a fila.</p>
            <div class="input-group">
                <label for="adminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="adminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="clearPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="clearPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="togglePassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="clearQueue()" id="clearQueueBtn">
                <span id="clearBtnText">Confirmar Limpeza</span>
                <span id="clearBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="removeModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeRemoveModal()">×</span>
            <h3><i class="fas fa-trash"></i> Remover Vídeo</h3>
            <p>Digite seu nome e a senha para remover o vídeo selecionado.</p>
            <div class="input-group">
                <label for="removeAdminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="removeAdminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="removePassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="removePassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleRemovePassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="removeVideo()" id="removeVideoBtn">
                <span id="removeBtnText">Confirmar Remoção</span>
                <span id="removeBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="ytSearchModal" class="modal yt-search-modal">
        <div class="modal-content">

            <div class="modal-header">
                <h3><i class="fab fa-youtube"></i> Buscar Vídeo no YouTube</h3>
                <button class="close-button" onclick="closeYTSearchModal()">&times;</button>
            </div>

            <div class="modal-body">

                <div class="session-info input-group">
                    <label><i class="fas fa-user"></i> Adicionando como: <strong
                            id="currentSessionUser">-</strong></label>
                    <button class="btn small secondary" onclick="changeUserName()">Alterar</button>
                </div>

                <div id="userNameInputGroup" class="input-group">
                    <label for="ytSearchName"><i class="fas fa-user"></i> Seu Nome:</label>
                    <input type="text" id="ytSearchName" placeholder="Quem está adicionando?">
                    <button class="btn small primary" onclick="setSessionUser()">Confirmar</button>
                </div>

                <div class="search-controls">
                    <input type="text" id="ytSearchQuery" placeholder="Digite sua busca">
                    <button class="btn primary" onclick="searchYouTube()">
                        <i class="fas fa-search"></i> Buscar
                    </button>
                </div>

                <div class="yt-search-results" id="ytSearchResults">
                </div>

            </div>
        </div>
    </div>

    <div id="notification" class="notification">
        <span id="notificationMessage"></span>
    </div>

    <!-- Proxiam faixa -->
    <div id="nextVideoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeNextVideoModal()">×</span>
            <h3><i class="fas fa-forward"></i> Próximo Vídeo</h3>
            <p>Digite seu nome e a senha de administrador para pular para o próximo vídeo.</p>
            <div class="input-group">
                <label for="nextAdminName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="nextAdminName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="nextPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="nextPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleNextPassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="playNextVideo()" id="playNextVideoBtn">
                <span id="playNextBtnText">Confirmar Próximo</span>
                <span id="playNextBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="adminUnlockModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAdminUnlockModal()">×</span>
            <h3><i class="fas fa-user-shield"></i> Login de Administrador</h3>
            <p>Digite suas credenciais para entrar no Modo Admin.</p>
            <div class="input-group">
                <label for="adminUnlockName"><i class="fas fa-user-shield"></i> E-mail do Admin:</label>
                <input type="email" id="adminUnlockName" placeholder="Seu e-mail" required>
            </div>
            <div class="input-group password-group">
                <label for="adminUnlockPassword"><i class="fas fa-lock"></i> Senha:</label>
                <input type="password" id="adminUnlockPassword" placeholder="Senha de administrador" required>
                <span class="toggle-password" id="toggleAdminUnlockPassword"><i class="fas fa-eye"></i></span>
            </div>
            <button class="btn primary" onclick="loginAdminSession()" id="adminUnlockConfirmBtn">
                <span id="adminUnlockConfirmBtnText">Login</span>
                <span id="adminUnlockConfirmBtnLoader" class="loading" style="display: none;"></span>
            </button>
        </div>
    </div>

    <div id="bulkRemoveConfirmModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeBulkRemoveConfirmModal()">×</span>
            <h3><i class="fas fa-exclamation-triangle"></i> Confirmar Remoção</h3>
            <p id="bulkRemoveMessage">Tem certeza que deseja remover os vídeos selecionados?</p>

            <div class="modal-buttons">
                <button class="btn secondary" onclick="closeBulkRemoveConfirmModal()">
                    Cancelar
                </button>
                <button class="btn danger" onclick="executeBulkRemove()" id="bulkRemoveConfirmBtn">
                    <span id="bulkRemoveConfirmBtnText">Remover</span>
                    <span id="bulkRemoveConfirmBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </div>
        </div>
    </div>

    <div id="panelModal" class="modal admin-panel-modal">
        <div class="modal-content">
            <span class="close-button" onclick="closePanelModal()">×</span>

            <div class="admin-panel-header">
                <h3><i class="fas fa-user-shield"></i> Painel Admin - FlowLink</h3>
            </div>

            <div class="admin-panel-body">
                <h4 style="display: flex; justify-content: space-between; align-items: center;">
                    <span><i class="fas fa-server"></i> Salas Ativas</span>
                    
                    <div style="display: flex;"> <button class="btn small secondary" onclick="loadAdminPanelRooms()" title="Atualizar lista">
                            <i class="fas fa-sync-alt"></i> Atualizar
                        </button>
                        
                        <button class="btn small danger" onclick="openDeleteAllRoomsModal()" title="Deletar TODAS as salas" style="margin-left: 10px;">
                            <i class="fas fa-exclamation-triangle"></i> Deletar Tudo
                        </button>
                    </div>
                </h4>

                <div id="adminRoomLoader" class="loading-yt" style="display: none; padding: 40px 0;">
                    Carregando salas...
                </div>

                <div id="adminRoomList" class="admin-room-list">
                </div>
            </div>
        </div>
    </div>

    <div id="deleteAllRoomsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeDeleteAllRoomsModal()">×</span>
            <h3><i class="fas fa-exclamation-triangle"></i> Deletar Todas as Salas</h3>
            <p>
                Tem certeza que deseja deletar <strong>TODAS</strong> as salas ativas?
                <br><br>
                Esta ação é <strong>irreversível</strong> e apagará todas as filas e chats de todos os usuários.
            </p>

            <div class="modal-buttons">
                <button class="btn secondary" onclick="closeDeleteAllRoomsModal()">
                    Cancelar
                </button>
                <button class="btn danger" onclick="executeDeleteAllRooms()" id="deleteAllRoomsConfirmBtn">
                    <span id="deleteAllRoomsConfirmBtnText">Sim, Deletar Tudo</span>
                    <span id="deleteAllRoomsConfirmBtnLoader" class="loading" style="display: none;"></span>
                </button>
            </div>
        </div>
    </div>

    <!-- //sessão -->
    <script>
        let currentSessionUser = null;

        function openYTSearchModal() {
            document.getElementById('ytSearchModal').style.display = 'flex';
            document.getElementById('ytSearchQuery').value = '';
            document.getElementById('ytSearchResults').innerHTML = '';

            // Mostra a interface apropriada baseada no estado
            if (currentSessionUser) {
                document.getElementById('currentSessionUser').textContent = currentSessionUser;
                document.getElementById('userNameInputGroup').style.display = 'none';
                document.querySelector('.session-info').style.display = 'flex';
                document.getElementById('ytSearchQuery').focus();
            } else {
                document.getElementById('userNameInputGroup').style.display = 'block';
                document.querySelector('.session-info').style.display = 'none';
                document.getElementById('ytSearchName').focus();
            }
        }

        function setSessionUser() {
            const userName = document.getElementById('ytSearchName').value.trim();

            if (!userName) {
                showNotification('Por favor, digite seu nome.', 'error');
                return;
            }

            currentSessionUser = userName;
            document.getElementById('currentSessionUser').textContent = userName;
            document.getElementById('userNameInputGroup').style.display = 'none';
            document.getElementById('userNameDisplay').textContent = userName;
            document.querySelector('.session-info').style.display = 'flex';
            document.getElementById('ytSearchQuery').focus();

            // Salva na sessionStorage para persistir entre recarregamentos
            sessionStorage.setItem('ytSessionUser', userName);

            // *** NOVA LINHA: Atualiza o nome na lista de presença ***
            if (myPresenceRef) {
                myPresenceRef.update({ name: userName });
            }
        }

        function changeUserName() {
            currentSessionUser = null;
            sessionStorage.removeItem('ytSessionUser');
            document.getElementById('ytSearchName').value = '';
            document.getElementById('userNameInputGroup').style.display = 'block';
            document.querySelector('.session-info').style.display = 'none';
            document.getElementById('ytSearchName').focus();
            document.getElementById('userNameDisplay').textContent = 'Visitante';
            // *** NOVA LINHA: Atualiza o nome para "Visitante" ***
            if (myPresenceRef) {
                myPresenceRef.update({ name: 'Visitante' });
            }
        }

        // Ao carregar a página, verifica se há um nome salvo
        window.addEventListener('DOMContentLoaded', function () {
            const savedUser = sessionStorage.getItem('ytSessionUser');
            if (savedUser) {
                currentSessionUser = savedUser;
                document.getElementById('userNameDisplay').textContent = savedUser;
            }
        });
    </script>
    <script>

        // ====================================================================
        // Funções para o modal de busca no YouTube
        function openYTSearchModal() {
            document.getElementById('ytSearchModal').style.display = 'flex';
            document.getElementById('ytSearchQuery').focus();
        }

        function closeYTSearchModal() {
            document.getElementById('ytSearchModal').style.display = 'none';
            document.getElementById('ytSearchQuery').value = '';
            document.getElementById('ytSearchResults').innerHTML = '';
        }

        function selectYouTubeVideo(videoUrl, videoTitle) {
            // Verifica se temos um usuário na sessão
            if (!currentSessionUser) {
                showNotification('Por favor, configure seu nome antes de adicionar vídeos.', 'error');
                // Mostra o campo de nome e foca nele
                document.getElementById('userNameInputGroup').style.display = 'block';
                document.querySelector('.session-info').style.display = 'none';
                document.getElementById('ytSearchName').focus();
                return;
            }

            // Preenche os campos no formulário principal automaticamente
            document.getElementById('phone').value = currentSessionUser;
            document.getElementById('videoUrl').value = videoUrl;

            // Não fecha o modal - permite adicionar mais vídeos
            // Mantém o modal aberto para continuar adicionando

            // Adiciona o vídeo à fila
            setTimeout(() => {
                addVideo();

                // Feedback visual que o vídeo foi adicionado
                showNotification(`"${videoTitle}" adicionado por ${currentSessionUser}`, 'success');

                // Rolagem suave para o resultado adicionado
                setTimeout(() => {
                    const videoList = document.getElementById('videoList');
                    if (videoList.lastChild) {
                        videoList.lastChild.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 300);
            }, 100);
        }

        async function searchYouTube() {
            const query = document.getElementById('ytSearchQuery').value.trim();
            if (!query) {
                showNotification('Digite algo para buscar no YouTube', 'error');
                return;
            }

            const resultsContainer = document.getElementById('ytSearchResults');
            resultsContainer.innerHTML = '<div class="loading-yt">Buscando vídeos...</div>';

            try {
                // Substitua pela sua chave de API do YouTube
                const API_KEY = 'AIzaSyADkfhlsuGQspanjkzd_2ypc023a5Zl4i0';
                const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=5&q=${encodeURIComponent(query)}&key=${API_KEY}&type=video`);

                if (!response.ok) throw new Error('Erro na API do YouTube');

                const data = await response.json();
                const videos = data.items.map(item => ({
                    title: item.snippet.title,
                    url: `https://www.youtube.com/watch?v=${item.id.videoId}`,
                    thumbnail: item.snippet.thumbnails.default.url
                }));

                displayYouTubeResults(videos);
            } catch (error) {
                console.error('Erro na busca do YouTube:', error);
                resultsContainer.innerHTML = '<div class="error-yt">Erro ao buscar vídeos. Tente novamente.</div>';
            }
        }

        function displayYouTubeResults(videos) {
            const resultsContainer = document.getElementById('ytSearchResults');
            resultsContainer.innerHTML = '';

            if (videos.length === 0) {
                resultsContainer.innerHTML = '<div class="empty-yt">Nenhum vídeo encontrado.</div>';
                return;
            }

            videos.forEach(video => {
                const videoElement = document.createElement('div');
                videoElement.className = 'yt-video-result';
                videoElement.innerHTML = `
            <div class="yt-video-thumbnail">
                <img src="${video.thumbnail}" alt="${video.title}">
            </div>
            <div class="yt-video-info">
                <h4>${video.title}</h4>
                <button class="btn primary small" onclick="selectYouTubeVideo('${video.url}')">
                    <i class="fas fa-plus"></i> Adicionar
                </button>
            </div>
        `;
                resultsContainer.appendChild(videoElement);
            });
        }

        // ====================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyCDlr4XHXuwWQ9Zj9dd2yoctLhFz1vbbyM",
            authDomain: "flowlink-7fd57.firebaseapp.com",
            databaseURL: "https://flowlink-7fd57-default-rtdb.firebaseio.com",
            projectId: "flowlink-7fd57",
            storageBucket: "flowlink-7fd57.firebasestorage.app",
            messagingSenderId: "1035085936175",
            appId: "1:1035085936175:web:2732042d77792118b8f8da",
            measurementId: "G-B0NE1GDVQK"
        };

        // Inicializa o Firebase
        firebase.initializeApp(firebaseConfig);

        // Obtém uma referência para o Realtime Database
        const database = firebase.database();

        // ====================================================================
        // INÍCIO DA MODIFICAÇÃO PARA SALAS
        // ====================================================================

        // 1. Pega o ID da sala da URL IMEDIATAMENTE.
        const urlParams = new URLSearchParams(window.location.search);
        const currentRoomId = urlParams.get('room');

        // 2. Se não houver ID, pare tudo e mostre um erro.
        if (!currentRoomId) {
            // Trava o body e mostra o erro
            document.body.style.overflow = 'hidden';
            document.body.innerHTML = `
                <div class="container" style="margin-top: 50px; text-align: center;">
                    <div class="card" style="padding: 40px;">
                        <h1><i class="fas fa-exclamation-triangle"></i> Erro: Sala não encontrada</h1>
                        <p style="color: var(--text-primary); font-size: 1.1rem; margin: 20px 0;">
                            Este link é inválido. Você precisa de um link de sala para usar o FlowLink.
                        </p>
                        <p style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 30px;">
                            (Ex: index.html?room=minha-sala-123)
                        </p>
                        <a href="create.html" class="btn primary" style="width: auto; padding: 14px 28px;">
                            <i class="fas fa-plus-circle"></i> Criar uma Nova Sala
                        </a>
                    </div>
                </div>`;

            // Para a execução do script para evitar mais erros
            throw new Error("ID da Sala (room) não fornecido na URL.");
        }

        // 3. Se temos um ID, defina TODAS as suas referências para usar esse ID.
        // Crie uma referência principal para a sala
        const roomRef = database.ref('rooms/' + currentRoomId);

        // 4. Substitua suas definições de const originais por estas:
        const videoQueueRef = roomRef.child('videoQueue');

        // ====================================================================
        // NOVO: Sistema de Presença em Tempo Real (MODIFICADO)
        // ====================================================================

        const presenceRef = roomRef.child('presence'); // <--- MODIFICADO
        const connectedRef = database.ref('.info/connected'); // (Este fica igual)
        let myPresenceRef = null; // Guardará a nossa própria referência de conexão

        // Monitora o status da conexão com o Firebase
        connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
                // Estamos conectados!
                console.log('Firebase conectado. Registrando presença na sala: ' + currentRoomId);

                // Pega o nome da sessão, se já existir
                let userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

                // Cria uma nova entrada única para este usuário na lista de presença DESTA SALA
                myPresenceRef = presenceRef.push();

                // Define o onDisconnect PRIMEIRO
                myPresenceRef.onDisconnect().remove();

                // Agora, define nosso estado online com nosso nome
                myPresenceRef.set({
                    name: userName,
                    joinedAt: firebase.database.ServerValue.TIMESTAMP
                });

            } else {
                // Estamos desconectados
                console.log('Firebase desconectado.');
            }
        });

        // Agora, vamos ouvir a contagem total de usuários online (DESTA SALA)
        const userCountElement = document.getElementById('userCount');
        presenceRef.on('value', (snap) => {
            const count = snap.numChildren();

            // Atualiza o header
            if (userCountElement) {
                userCountElement.textContent = count;
            }

            // ATUALIZA O CHAT
            const chatOnlineCount = document.getElementById('onlineCount');
            if (chatOnlineCount) {
                chatOnlineCount.textContent = count;
            }
        });
        // ====================================================================
        // Fim do Sistema de Presença
        // ====================================================================

        // ====================================================================
        // NOVO: Funções de Sessão de Admin (Login/Logout)
        // ====================================================================

        function openAdminUnlockModal() {
            // Se o admin já estiver logado, o botão vira "Logout"
            if (isAdminLoggedIn) {
                logoutAdminSession();
                document.body.classList.add('non-admin');
                disableAdminPlayerControls();

                return; // Não abre o modal
            }
            // Se não, abre o modal de login
            document.getElementById('adminUnlockModal').style.display = 'flex';
            document.getElementById('adminUnlockName').focus();
        }

        function closeAdminUnlockModal() {
            document.getElementById('adminUnlockModal').style.display = 'none';
            document.getElementById('adminUnlockName').value = '';
            document.getElementById('adminUnlockPassword').value = '';
        }

        // NOVO: Fecha o modal de confirmação de remoção em lote
        function closeBulkRemoveConfirmModal() {
            document.getElementById('bulkRemoveConfirmModal').style.display = 'none';
            // Limpa o array de IDs para garantir
            videoIdsForBulkRemove = [];
        }

        async function loginAdminSession() {
            const adminEmail = document.getElementById('adminUnlockName').value.trim();
            const password = document.getElementById('adminUnlockPassword').value;
            document.body.classList.remove('non-admin');

            enableAdminPlayerControls();

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha e-mail e senha.', 'error');
                return;
            }

            toggleLoading('adminUnlockConfirmBtn', true);

            try {
                // Tenta fazer o login no Firebase Auth
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // SUCESSO!
                isAdminLoggedIn = true; // Define o estado global
                const adminBtn = document.getElementById('adminUnlockBtn');
                adminBtn.classList.add('admin-logged-in'); // Deixa o botão verde
                adminBtn.innerHTML = '<i class="fas fa-unlock"></i> Admin'; // Muda o ícone
                document.body.classList.remove('non-admin');
                showNotification('Modo Admin ATIVADO.', 'success');
                closeAdminUnlockModal();

                // *** PARTE 2: Mostra os controles de admin ***
                document.getElementById('panelBtn').style.display = 'flex';
                document.getElementById('videoList').classList.add('admin-mode');
                document.getElementById('bulkRemoveBtn').style.display = 'inline-block';
                document.getElementById('clearChatBtn').style.display = 'inline-block';

                enableAdminPlayerControls();
            } catch (error) {
                console.error('Erro de autenticação do admin:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido.', 'error');
                } else {
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('adminUnlockConfirmBtn', false);
            }
        }

        function disableAdminPlayerControls() {
            if (!player || typeof YT === 'undefined') return;

            // --- INÍCIO DA CORREÇÃO ---
            let videoData;
            try {
                videoData = player.getVideoData();
            } catch (e) {
                console.warn('Player não está pronto, não é possível desativar controles de admin.');
                return; // Sai se o player não estiver pronto
            }

            const currentVideoId = videoData ? videoData.video_id : null;

            // Se não houver vídeo (fila vazia), apenas saia.
            if (!currentVideoId) {
                console.log('Nenhum vídeo tocando. Controles de admin desativados (sem recriar player).');
                // Mostra a máscara mesmo se não houver vídeo
                document.getElementById('player-mask').style.display = 'block';
                return;
            }
            // --- FIM DA CORREÇÃO ---

            const currentTime = player.getCurrentTime();

            player.destroy();

            // recria o player bloqueado (sem controles nativos)
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                videoId: currentVideoId,
                playerVars: {
                    autoplay: 1,
                    controls: 0, // <-- remove os botões nativos
                    modestbranding: 1,
                    rel: 0,
                    disablekb: 1
                },
                events: {
                    onReady: (event) => {
                        event.target.seekTo(currentTime);
                        event.target.playVideo();

                        // mostra a máscara novamente
                        document.getElementById('player-mask').style.display = 'block';
                    },
                    onStateChange: onPlayerStateChange
                }
            });
        }


        function enableAdminPlayerControls() {
            if (!player || typeof YT === 'undefined') return;

            const currentVideoId = player.getVideoData().video_id;
            const currentTime = player.getCurrentTime();

            player.destroy(); // remove o player atual

            // recria com controles nativos
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                videoId: currentVideoId,
                playerVars: {
                    autoplay: 1,
                    controls: 1, // <-- habilita os botões do YouTube
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onReady: (event) => {
                        event.target.seekTo(currentTime);
                        event.target.playVideo();
                    },
                    onStateChange: onPlayerStateChange
                }
            });

            function enableAdminPlayerControls() {
                if (!player || typeof YT === 'undefined') return;

                let videoData;
                try {
                    videoData = player.getVideoData();
                } catch (e) {
                    console.warn('Player não está pronto, não é possível ativar controles de admin.');
                    return; // Sai se o player não estiver pronto
                }

                const currentVideoId = videoData ? videoData.video_id : null;

                // Se não houver vídeo (fila vazia), apenas saia.
                if (!currentVideoId) {
                    console.log('Nenhum vídeo tocando. Controles de admin ativados (sem recriar player).');
                    // Esconde a máscara mesmo se não houver vídeo
                    document.getElementById('player-mask').style.display = 'none';
                    return;
                }
                // --- FIM DA CORREÇÃO ---

                const currentTime = player.getCurrentTime();

                player.destroy(); // remove o player atual

                // recria com controles nativos
                player = new YT.Player('videoPlayer', {
                    height: '100%',
                    width: '100%',
                    videoId: currentVideoId,
                    playerVars: {
                        autoplay: 1,
                        controls: 1, // <-- habilita os botões do YouTube
                        modestbranding: 1,
                        rel: 0
                    },
                    events: {
                        onReady: (event) => {
                            event.target.seekTo(currentTime);
                            event.target.playVideo();

                            // 👇 Esconde a máscara para liberar cliques
                            document.getElementById('player-mask').style.display = 'none';
                        },
                        onStateChange: onPlayerStateChange
                    }
                });
            }

        }


        function logoutAdminSession() {
            isAdminLoggedIn = false; // Desliga o modo admin
            document.body.classList.add('non-admin');
            const adminBtn = document.getElementById('adminUnlockBtn');
            adminBtn.classList.remove('admin-logged-in'); // Deixa o botão vermelho
            adminBtn.innerHTML = '<i class="fas fa-lock"></i> Admin'; // Muda o ícone
            showNotification('Modo Admin DESATIVADO.', 'info');

            // *** PARTE 2: Esconde os controles de admin ***
            document.getElementById('panelBtn').style.display = 'none';
            document.getElementById('videoList').classList.remove('admin-mode');
            document.getElementById('bulkRemoveBtn').style.display = 'none';
            document.getElementById('clearChatBtn').style.display = 'none';
            // Limpa os checkboxes
            document.querySelectorAll('.video-select-checkbox').forEach(cb => cb.checked = false);
        }

        // Adiciona o listener do "olho" da senha para o novo modal
        document.getElementById('toggleAdminUnlockPassword').addEventListener('click', function () {
            const passwordField = document.getElementById('adminUnlockPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        let videoQueue = []; // Array local para espelhar a fila do Firebase
        let player; // Variável para o player do YouTube
        let videoToRemoveId = null; // ID do vídeo a ser removido (usado no modal de remoção)
        let isAdminLoggedIn = false; // NOVO: Estado de login do Admin
        let videoIdsForBulkRemove = [];
        let notificationTimer = null;
        /**
 * Exibe uma notificação temporária na tela.
 * (Versão corrigida para evitar bugs de 'race condition')
 * @param {string} message - A mensagem a ser exibida.
 * @param {string} [type='info'] - O tipo da notificação ('info', 'success', 'error').
 */
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notificationMessage');

            // 1. Limpa qualquer timer de notificação anterior
            // Isso impede que a notificação desapareça se uma nova for chamada
            if (notificationTimer) {
                clearTimeout(notificationTimer);
            }

            notificationMessage.textContent = message;
            notification.className = 'notification'; // Reseta as classes
            notification.classList.add(type, 'show'); // Adiciona as novas

            // 2. Define um NOVO timer para 5 segundos (aumentado de 3000)
            notificationTimer = setTimeout(() => {
                notification.classList.remove('show');
                notificationTimer = null; // Limpa o ID do timer
            }, 5000); // <-- Aumentado de 3000ms para 5000ms
        }


        /**
         * Alterna o estado de carregamento de um botão (mostra/oculta um spinner).
         * @param {string} buttonId - O ID do botão.
         * @param {boolean} isLoading - True para mostrar o carregamento, false para ocultar.
         */
        function toggleLoading(buttonId, isLoading) {
            const btn = document.getElementById(buttonId);
            const btnText = btn ? btn.querySelector(`#${buttonId.replace('Btn', 'BtnText')}`) : null;
            const btnLoader = btn ? btn.querySelector(`#${buttonId.replace('Btn', 'BtnLoader')}`) : null;

            if (!btn || !btnText || !btnLoader) {
                console.error(`Um ou mais elementos para o botão ${buttonId} não foram encontrados.`);
                return;
            }

            if (isLoading) {
                btn.disabled = true;
                btnText.style.display = 'none';
                btnLoader.style.display = 'inline-block';
            } else {
                btn.disabled = false;
                btnText.style.display = 'inline';
                btnLoader.style.display = 'none';
            }
        }

        /**
         * Adiciona um novo vídeo à fila no Firebase Realtime Database.
         */
        async function addVideo() {
            const phone = document.getElementById('phone').value.trim();
            const videoUrl = document.getElementById('videoUrl').value.trim();

            if (!phone || !videoUrl) {
                showNotification('Por favor, preencha o nome e a URL do vídeo.', 'error');
                return;
            }

            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            if (!youtubeRegex.test(videoUrl)) {
                showNotification('Por favor, insira uma URL de vídeo válida do YouTube.', 'error');
                return;
            }

            toggleLoading('addVideoBtn', true);

            try {
                const newVideoRef = videoQueueRef.push();
                await newVideoRef.set({
                    id: newVideoRef.key,
                    phone: phone,
                    videoUrl: videoUrl
                });

                showNotification('Vídeo adicionado com sucesso!', 'success');

                document.getElementById('phone').value = '';
                document.getElementById('videoUrl').value = '';

            } catch (error) {
                console.error('Erro ao adicionar vídeo ao Firebase:', error);
                showNotification('Erro ao adicionar o vídeo. Verifique a conexão com o Firebase.', 'error');
            } finally {
                toggleLoading('addVideoBtn', false);
            }
        }

        /**
         * Carrega a fila de vídeos do Firebase Realtime Database e atualiza a UI.
         * Esta função usa um listener 'value' que é acionado sempre que os dados na referência mudam.
         */
        function loadVideoQueue() {
            videoQueueRef.on('value', async (snapshot) => {
                const data = snapshot.val();
                let fetchedQueue = [];

                if (data) {
                    fetchedQueue = Object.keys(data).map(key => ({
                        id: key,
                        ...data[key]
                    }));
                }

                videoQueue = fetchedQueue;
                const videoList = document.getElementById('videoList');
                videoList.innerHTML = '';
                // NOVO: Aplica a classe de admin se estiver logado
                if (isAdminLoggedIn) {
                    videoList.classList.add('admin-mode');
                } else {
                    videoList.classList.remove('admin-mode');
                }



                if (videoQueue.length === 0) {
                    videoList.innerHTML = '<li class="empty-queue">A fila de vídeos está vazia. Adicione um vídeo!</li>';
                    document.getElementById('currentUser').textContent = 'Nenhum vídeo em execução';
                    document.getElementById('currentVideoUrl').textContent = 'Nenhuma URL disponível';
                    if (player && typeof player.stopVideo === 'function') {
                        player.stopVideo();
                    }
                    return;
                }

                async function getFormattedVideoTitle(url) {
                    try {
                        // Tenta pegar do cache primeiro
                        const videoId = extractVideoId(url);
                        const cachedTitle = sessionStorage.getItem(`videoTitle_${videoId}`);

                        if (cachedTitle) {
                            return cachedTitle;
                        }

                        // Se não tiver em cache, busca da API do YouTube
                        const API_KEY = 'AIzaSyADkfhlsuGQspanjkzd_2ypc023a5Zl4i0'; // Substitua pela sua chave
                        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${API_KEY}`);

                        if (response.ok) {
                            const data = await response.json();
                            if (data.items && data.items[0]) {
                                const title = data.items[0].snippet.title;
                                // Armazena no cache para próximas vezes
                                sessionStorage.setItem(`videoTitle_${videoId}`, title);
                                return title;
                            }
                        }
                    } catch (error) {
                        console.error('Erro ao buscar título:', error);
                    }

                    // Fallback: Mostra "Música (ID do vídeo)" se não conseguir o título
                    const videoId = extractVideoId(url);
                    return videoId ? `Música (ID: ${videoId})` : 'Vídeo do YouTube';
                }
                // Preenche a lista na UI com títulos melhorados
                for (const video of videoQueue) {
                    const listItem = document.createElement('li');
                    listItem.classList.add('video-item');

                    // Obtém o título formatado
                    const videoTitle = await getFormattedVideoTitle(video.videoUrl);

                    listItem.innerHTML = `
            <div class="bulk-delete-controls">
                <input type="checkbox" class="video-select-checkbox" data-videoid="${video.id}" title="Selecionar para remover">
            </div>

            <div class="video-info">
                <span class="video-title">${videoTitle}</span>
                <div class="video-meta">
                    <span class="video-added-by">Adicionado por: ${video.phone}</span>
                    <a href="${video.videoUrl}" target="_blank" class="video-link">
                        <i class="fab fa-youtube"></i> Assistir
                    </a>
                </div>
            </div>
            <button class="remove-button" onclick="openRemoveModalWithId('${video.id}')" title="Remover vídeo">
                <i class="fas fa-times"></i>
            </button>
        `;
                    videoList.appendChild(listItem);
                }

                // Mantém a lógica do player
                let currentlyPlayingVideoIdInPlayer = null;
                if (player && typeof player.getVideoData === 'function') {
                    try {
                        currentlyPlayingVideoIdInPlayer = player.getVideoData().video_id;
                    } catch (e) {
                        console.warn("Player.getVideoData() falhou:", e);
                    }
                }

                const firstVideoInQueue = videoQueue[0];
                const firstVideoInQueueId = extractVideoId(firstVideoInQueue.videoUrl);

                if (player && typeof player.loadVideoById === 'function') {
                    const firstVideoInQueue = videoQueue[0];
                    const firstVideoInQueueId = extractVideoId(firstVideoInQueue.videoUrl);

                    // Obter o ID do vídeo atualmente carregado no player, se houver
                    let currentlyLoadedVideoId = null;
                    if (player.getVideoData && typeof player.getVideoData === 'function') {
                        try {
                            currentlyLoadedVideoId = player.getVideoData().video_id;
                        } catch (e) {
                            console.warn("Player.getVideoData() falhou ou player não está pronto para obter dados do vídeo:", e);
                        }
                    }

                    // Apenas carregue um novo vídeo se:
                    // 1. Não houver nenhum vídeo carregado no player (início).
                    // 2. O ID do primeiro vídeo na fila for diferente do vídeo atualmente carregado.
                    // 3. (Opcional, mas recomendado) O player não estiver no estado de "playing" E o vídeo que deveria tocar for o primeiro da fila
                    //    Isso serve para garantir que ele reinicie se o vídeo atual for o certo, mas ele parou por algum motivo (erro, etc.)
                    if (currentlyLoadedVideoId === null ||
                        currentlyLoadedVideoId !== firstVideoInQueueId ||
                        (player.getPlayerState() !== YT.PlayerState.PLAYING && currentlyLoadedVideoId === firstVideoInQueueId)
                    ) {
                        updateVideoPlayer(firstVideoInQueue.videoUrl, firstVideoInQueue.phone);
                    }
                } else {
                    console.warn('Player do YouTube não está pronto para carregar o vídeo.');
                }
            });
        }

        /**
         * Extrai o ID do vídeo de uma URL do YouTube.
         * @param {string} url - A URL do YouTube.
         * @returns {string|null} O ID do vídeo ou null se não for uma URL válida.
         */
        function extractVideoId(url) {
            const regExp = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            const match = url.match(regExp);
            return (match && match[1]) ? match[1] : null;
        }

        /**
         * Obtém um título genérico para o vídeo com base no ID.
         * @param {string} url - A URL do vídeo.
         * @returns {string} O título do vídeo.
         */
        function getVideoTitle(url) {
            const videoId = extractVideoId(url);
            return videoId ? `Vídeo (ID: ${videoId})` : 'Vídeo do YouTube'; // Ou você pode usar uma API para obter o título real
        }

        /**
         * Carrega e reproduz um vídeo no player do YouTube.
         * @param {string} videoUrl - A URL do vídeo a ser carregado.
         * @param {string} userName - O nome do usuário que adicionou o vídeo.
         */
        function updateVideoPlayer(videoUrl, userName) {
            const videoId = extractVideoId(videoUrl);

            if (videoId && player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoId);
                document.getElementById('currentUser').textContent = userName;
                document.getElementById('currentVideoUrl').textContent = videoUrl;
            } else {
                console.error('URL do YouTube inválida ou player não pronto:', videoUrl);
                document.getElementById('currentUser').textContent = 'Nenhum vídeo em execução';
                document.getElementById('currentVideoUrl').textContent = 'Nenhuma URL disponível';
                if (player && typeof player.stopVideo === 'function') {
                    player.stopVideo();
                }
            }
        }

        /**
         * Função chamada quando o estado do player do YouTube muda.
         * Se o vídeo terminar, ele remove o vídeo atual da fila do Firebase.
         * O listener 'value' do Firebase se encarrega de carregar o próximo.
         * @param {Object} event - O objeto de evento do player do YouTube.
         */
        let lastKnownTime = 0;
        let timeCheckInterval;

        function startProgressMonitor() {
            if (timeCheckInterval) {
                clearInterval(timeCheckInterval);
            }

            timeCheckInterval = setInterval(() => {
                if (player && typeof player.getCurrentTime === 'function' && player.getPlayerState() === YT.PlayerState.PLAYING) {
                    const currentTime = player.getCurrentTime();
                    const duration = player.getDuration();

                    const jumpThreshold = 5; // Se avançar mais que 5s
                    const remainingTimeThreshold = 50; // E estiver nos últimos 5s

                    const jumped = currentTime > lastKnownTime + jumpThreshold;
                    const nearEnd = currentTime >= duration - remainingTimeThreshold && currentTime < duration;

                    if (jumped && !nearEnd) {
                        console.log('Detectado adiantamento no vídeo.');
                    } else if (jumped && nearEnd) {
                        // ← ADIANTAMENTO PARA PERTO DO FINAL DETECTADO
                        console.log('Detectado adiantamento para o final do vídeo.');

                        player.pauseVideo();
                        player.seekTo(lastKnownTime + 1, true);
                        showNotification('Você não pode adiantar o vídeo até o final.', 'error');

                        return; // ← NÃO ATUALIZA lastKnownTime!
                    }

                    // Só atualiza se não houver adiantamento suspeito
                    lastKnownTime = currentTime;
                }
            }, 1000);
        }


        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                const currentTime = player.getCurrentTime();
                const duration = player.getDuration();
                // Definimos uma tolerância. Se o vídeo terminou dentro, digamos,
                // dos últimos 1.5 segundos da duração total, consideramos que foi um fim natural.
                const naturalEndTolerance = 0.5; // Se você quer que o vídeo só pule se realmente chegar ao fim exato // Ajuste este valor se necessário (0.5 a 2 segundos é um bom ponto de partida)

                // Se o tempo atual estiver muito próximo da duração total, consideramos um fim natural.
                if (duration - currentTime <= naturalEndTolerance) {
                    console.log('Vídeo terminou naturalmente. Avançando para o próximo...');
                    // Lógica para avanço automático (fim natural)
                    if (videoQueue.length > 0) {
                        const firstVideoInQueue = videoQueue[0];
                        const currentPlayingVideoIdInPlayer = player.getVideoData().video_id;
                        const expectedVideoIdInQueue = extractVideoId(firstVideoInQueue.videoUrl);

                        // Garante que o vídeo que terminou é o primeiro da fila antes de remover
                        if (currentPlayingVideoIdInPlayer === expectedVideoIdInQueue) {
                            videoQueueRef.child(firstVideoInQueue.id).remove()
                                .then(() => {
                                    console.log('Vídeo atual removido da fila automaticamente (fim natural).');
                                    // O listener do Firebase (loadVideoQueue) cuidará de carregar o próximo
                                })
                                .catch(error => {
                                    console.error('Erro ao remover vídeo automaticamente do Firebase:', error);
                                    showNotification('Erro ao avançar o vídeo automaticamente. Tente novamente.', 'error');
                                });
                        } else {
                            console.warn('O vídeo que terminou não é o primeiro da fila esperada. Nenhuma remoção automática.');
                        }
                    } else {
                        console.log('Fila vazia, não há vídeos para remover automaticamente.');
                        // Opcional: Pare o player se a fila estiver vazia
                        if (player && typeof player.stopVideo === 'function') {
                            player.stopVideo();
                        }
                    }
                } else {
                    // Este bloco será executado se o vídeo atingiu o estado ENDED,
                    // mas o tempo atual estava significativamente longe do final (ou seja, foi adiantado).
                    console.log('Vídeo foi adiantado/pulado para o fim. NÃO avançando automaticamente. Tempo atual:', currentTime, 'Duração:', duration);
                    showNotification('O vídeo atual foi adiantado. Por favor, use o botão "Próximo Vídeo" e as credenciais de administrador para avançar a fila.', 'info');

                    // É uma boa prática parar o player para que ele não tente reiniciar ou loop se autoplay estiver ativado
                    if (player && typeof player.stopVideo === 'function') {
                        player.stopVideo();
                    }
                }
            }
        }

        // Função para atualizar a exibição do nome do admin
        function updateAdminDisplay() {
            const adminBtn = document.getElementById('adminUnlockBtn');
            const adminStatusText = document.getElementById('adminStatusText');
            const adminNameDisplay = document.getElementById('adminNameDisplay');
            const adminInfo = document.getElementById('adminInfo');
            const adminFullName = document.getElementById('adminFullName');

            if (isAdminLoggedIn && currentAdminUser) {
                adminBtn.classList.add('admin-logged-in');
                adminStatusText.textContent = 'Admin:';
                adminNameDisplay.textContent = currentAdminUser;
                adminNameDisplay.style.display = 'inline';

                // Mostra info adicional se existir
                if (adminInfo && adminFullName) {
                    adminFullName.textContent = currentAdminUser;
                    adminInfo.style.display = 'flex';
                }
            } else {
                adminBtn.classList.remove('admin-logged-in');
                adminStatusText.textContent = 'Admin';
                adminNameDisplay.style.display = 'none';
                adminNameDisplay.textContent = '';

                // Esconde info adicional se existir
                if (adminInfo) {
                    adminInfo.style.display = 'none';
                }
            }
        }

        // Variável para armazenar o nome do admin logado
        let currentAdminUser = null;

        // Modifique a função loginAdminSession para armazenar o nome do admin
        async function loginAdminSession() {
            const adminEmail = document.getElementById('adminUnlockName').value.trim();
            const password = document.getElementById('adminUnlockPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha e-mail e senha.', 'error');
                return;
            }

            toggleLoading('adminUnlockConfirmBtn', true);

            try {
                // Tenta fazer o login no Firebase Auth
                const userCredential = await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // SUCESSO!
                isAdminLoggedIn = true;
                currentAdminUser = adminEmail.split('@')[0]; // Pega a parte antes do @ como nome
                document.body.classList.remove('non-admin');

                // Atualiza a exibição
                updateAdminDisplay();
                closeAdminUnlockModal();

                // Mostra os controles de admin
                document.getElementById('videoList').classList.add('admin-mode');
                document.getElementById('bulkRemoveBtn').style.display = 'inline-block';
                document.getElementById('clearChatBtn').style.display = 'inline-block';

                document.getElementById('panelBtn').style.display = 'flex';

                enableAdminPlayerControls();

                // Atualiza o botão de pular para o modo Admin
                document.getElementById('skipVoteBtnText').textContent = 'Pular Vídeo (Admin)';
                document.getElementById('voteCounterWrapper').style.display = 'none'

            } catch (error) {
                console.error('Erro de autenticação do admin:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido.', 'error');
                } else {
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('adminUnlockConfirmBtn', false);
            }
        }

        // Modifique a função logoutAdminSession para limpar o nome
        function logoutAdminSession() {
            document.getElementById('adminPanelBtn').style.display = 'none';
            isAdminLoggedIn = false;
            currentAdminUser = null;
            document.body.classList.add('non-admin');

            // Atualiza a exibição
            updateAdminDisplay();

            showNotification('Modo Admin DESATIVADO.', 'info');

            // Esconde os controles de admin
            document.getElementById('videoList').classList.remove('admin-mode');
            document.getElementById('bulkRemoveBtn').style.display = 'none';
            document.getElementById('clearChatBtn').style.display = 'none';
            // Limpa os checkboxes
            document.querySelectorAll('.video-select-checkbox').forEach(cb => cb.checked = false);
            // Restaura o botão de pular para o modo Votação
            document.getElementById('skipVoteBtnText').textContent = 'Votar para Pular';
            document.getElementById('voteCounterWrapper').style.display = 'inline';
            disableAdminPlayerControls();
        }

        /**
                 * Função "portão" que decide se deve VOTAR ou PULAR (admin).
                 * Esta função é chamada pelo botão principal de skip.
                 */
        function handleSkipOrVote() {
            if (isAdminLoggedIn) {
                // Admin logado: Pula o vídeo imediatamente
                console.log('Admin logado. Pulando vídeo (via handleSkipOrVote)...');
                executeSkipVideo(); // Esta é a função de skip direto
            } else {
                // Usuário normal: Registra um voto
                console.log('Usuário normal. Registrando voto para pular (via handleSkipOrVote)...');
                castVoteToSkip(); // Esta é a função de votação
            }
        }
        // Variável para armazenar o ID do vídeo a ser removido (o que acabou de tocar)
        // (Mantenha esta variável no escopo global ou onde 'videoToRemoveId' está)
        /**
                 * Função "portão" para pular o vídeo.
                 * Verifica se o admin está logado. Se sim, pula direto.
                 * Se não, abre o modal de autenticação.
                 */
        function handleSkipVideo() {
            // Verifica se a fila está vazia
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return;
            }

            if (isAdminLoggedIn) {
                // Admin está logado: executa a lógica de pular diretamente
                console.log('Admin logado. Pulando vídeo...');
                executeSkipVideo(); // Não precisa de 'await'
            } else {
                // Admin não está logado: abre o modal para pedir credenciais
                console.log('Admin não logado. Abrindo modal de autenticação...');
                openNextVideoModal();
            }
        }

        /**
         * Abre o modal para avançar para o próximo vídeo, pedindo credenciais do admin.
         */
        function openNextVideoModal() {
            // Se a fila estiver vazia, não há próximo vídeo para avançar
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return;
            }

            // O ID do vídeo que está atualmente em execução (o primeiro da fila)
            // será o que será removido quando o admin confirmar.


            document.getElementById('nextVideoModal').style.display = 'flex';
            document.getElementById('nextAdminName').focus(); // Foca no campo de nome
        }

        /**
         * Fecha o modal de "Próximo Vídeo" e limpa os campos.
         */
        function closeNextVideoModal() {
            document.getElementById('nextVideoModal').style.display = 'none';
            document.getElementById('nextAdminName').value = '';
            document.getElementById('nextPassword').value = '';

        }

        /**
         * Função para avançar para o próximo vídeo na fila, após autenticação do admin.
         */
        async function playNextVideo() {
            const adminEmail = document.getElementById('nextAdminName').value.trim();
            const password = document.getElementById('nextPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha o nome e a senha de administrador.', 'error');
                return;
            }

            // A verificação da fila será feita pela executeSkipVideo, 
            // mas é bom ter aqui para fechar o modal se a fila esvaziou.
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                closeNextVideoModal();
                return;
            }

            toggleLoading('playNextVideoBtn', true);

            try {
                // 1. Tenta autenticar
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // 2. Se autenticou, executa a lógica de pular
                const success = await executeSkipVideo();

                // 3. Se a lógica de pular foi bem-sucedida, fecha o modal
                if (success) {
                    closeNextVideoModal();
                }

            } catch (error) {
                console.error('Erro de autenticação ou ao avançar vídeo:', error);

                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    // Erro genérico de autenticação
                    showNotification('Erro de autenticação.', 'error');
                }
            } finally {
                toggleLoading('playNextVideoBtn', false);
            }
        }

        // Event listener para alternar a visibilidade da senha no modal "Próximo Vídeo"
        document.getElementById('toggleNextPassword').addEventListener('click', function () {
            const passwordField = document.getElementById('nextPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        /**
         * Lógica central para avançar o vídeo.
         * Remove o primeiro vídeo da fila.
         * @returns {Promise<boolean>} - Retorna 'true' se foi bem-sucedido, 'false' se falhou.
         */
        async function executeSkipVideo() {
            if (videoQueue.length === 0) {
                showNotification('A fila está vazia. Não há próximo vídeo para avançar.', 'info');
                return false; // Retorna 'false' para indicar falha
            }

            try {
                // O ID do vídeo a ser removido é sempre o primeiro na fila
                const idToRemove = videoQueue[0].id;
                await videoQueueRef.child(idToRemove).remove();

                showNotification('Avançando para o próximo vídeo!', 'success');
                return true; // Retorna 'true' para indicar sucesso
            } catch (error) {
                console.error('Erro ao avançar vídeo:', error);
                showNotification('Erro ao avançar o vídeo. Verifique a conexão.', 'error');
                return false; // Retorna 'false' para indicar falha
            }
        }

        // ====================================================================
        // NOVO: Função de Remoção em Lote
        // ====================================================================
        // Esta função agora APENAS abre o modal de confirmação
        function removeSelectedVideos() {
            // Apenas admins logados podem usar
            if (!isAdminLoggedIn) {
                showNotification('Você precisa estar no Modo Admin para fazer isso.', 'error');
                return;
            }

            // 1. Encontra todos os checkboxes marcados
            const selectedCheckboxes = document.querySelectorAll('.video-select-checkbox:checked');

            if (selectedCheckboxes.length === 0) {
                showNotification('Nenhum vídeo selecionado para remoção.', 'info');
                return;
            }

            // 2. Pega os IDs de cada um e salva na variável global
            // (Substitui a const videoIdsToRemove)
            videoIdsForBulkRemove = Array.from(selectedCheckboxes).map(cb => cb.dataset.videoid);

            // 3. Prepara e abre o modal de confirmação (Substitui o 'confirm()')
            // (Isto assume que seu modal tem um <p> com id="bulkRemoveMessage")
            document.getElementById('bulkRemoveMessage').textContent = `Tem certeza que deseja remover ${videoIdsForBulkRemove.length} vídeos da fila? Esta ação não pode ser desfeita.`;

            // (Isto assume que seu modal de confirmação tem id="bulkRemoveConfirmModal")
            document.getElementById('bulkRemoveConfirmModal').style.display = 'flex';
        }

        // NOVO: Esta função é chamada pelo modal para EXECUTAR a remoção
        async function executeBulkRemove() {
            // 1. Pega os IDs da variável global
            if (videoIdsForBulkRemove.length === 0) {
                showNotification('Erro: Nenhum vídeo selecionado.', 'error');
                closeBulkRemoveConfirmModal();
                return;
            }

            toggleLoading('bulkRemoveConfirmBtn', true); // Ativa o loading

            // 2. Cria um array de "promessas" de remoção
            let removePromises = [];
            videoIdsForBulkRemove.forEach(id => {
                removePromises.push(videoQueueRef.child(id).remove());
            });

            // 3. Executa todas as remoções em paralelo
            try {
                await Promise.all(removePromises);
                showNotification(`${videoIdsForBulkRemove.length} vídeos removidos com sucesso.`, 'success');
            } catch (error) {
                console.error("Erro ao remover vídeos em lote:", error);
                showNotification('Ocorreu um erro ao remover os vídeos.', 'error');
            } finally {
                toggleLoading('bulkRemoveConfirmBtn', false); // Desativa o loading
                closeBulkRemoveConfirmModal(); // Fecha o modal e limpa o array
            }
        }


        /**
         * Função chamada quando a API do YouTube Iframe está pronta.
    // ... (o resto da sua função onYouTubeIframeAPIReady começa aqui)
        /**
         * Função chamada quando a API do YouTube Iframe está pronta.
         * Inicializa o player e carrega a fila de vídeos.
         */
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('videoPlayer', {
                height: '100%',
                width: '100%',
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,        // <- esconder controles nativos
                    'modestbranding': 1,
                    'rel': 0,
                    'disablekb': 1        // desativa teclas de atalho para evitar seek via teclado
                },
                events: {
                    'onReady': (event) => {
                        // define volume inicial e carrega fila
                        player.setVolume(50);
                        loadVideoQueue();
                    },
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // ======== Controles do overlay ========
        const overlayPlayBtn = document.getElementById('overlayPlayBtn');
        const overlayPlayIcon = document.getElementById('overlayPlayIcon');
        const overlayVolume = document.getElementById('overlayVolume');


        const overlayFullscreenBtn = document.getElementById('overlayFullscreenBtn');


        overlayFullscreenBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFullscreen();
        });

        function toggleFullscreen() {
            const container = document.getElementById('player-container');
            if (!document.fullscreenElement) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }

        }

        function updateOverlayPlayIcon() {
            if (!player || typeof player.getPlayerState !== 'function') return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                overlayPlayIcon.className = 'fas fa-pause';
            } else {
                overlayPlayIcon.className = 'fas fa-play';
            }
        }

        function togglePlayPauseFromOverlay() {
            if (!player) return;
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
            setTimeout(updateOverlayPlayIcon, 100); // atualiza ícone logo depois
        }

        function setVolumeFromOverlay(value) {
            if (!player || typeof player.setVolume !== 'function') return;
            player.setVolume(Number(value));
            showNotification(`Volume: ${value}%`, 'info');
        }

        // listeners
        overlayPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePlayPauseFromOverlay();
        });

        overlayVolume.addEventListener('input', (e) => {
            e.stopPropagation();
            setVolumeFromOverlay(e.target.value);
        });

        // Também atualiza ícone quando o estado do player muda pela API (ex.: autoplay)
        function onPlayerStateChange(event) {
            // chama seu código existente para ended, etc.
            // === mantenha o bloco que você já tinha para YT.PlayerState.ENDED ===
            // ... (seu código anterior de onPlayerStateChange permanece)
            // depois, atualize ícone do overlay
            setTimeout(updateOverlayPlayIcon, 50);
        }

        function handleClearQueue() {
            if (isAdminLoggedIn) {
                // Admin está logado: executa a lógica de limpar diretamente
                console.log('Admin logado. Limpando fila...');
                executeClearQueue(); // Não precisa de 'await'
            } else {
                // Admin não está logado: abre o modal para pedir credenciais
                console.log('Admin não logado. Abrindo modal de autenticação...');
                openModal();
            }
        }

        /**
         * Abre o modal para limpar a fila.
         */
        function openModal() {
            document.getElementById('modal').style.display = 'flex';
            document.getElementById('adminName').focus();
        }

        /**
         * Fecha o modal para limpar a fila e limpa os campos.
         */
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
            document.getElementById('adminName').value = '';
            document.getElementById('clearPassword').value = '';
        }

        /**
         * Abre o modal para remover um vídeo específico.
         * @param {string} id - O ID (chave do Firebase) do vídeo a ser removido.
         */
        function openRemoveModalWithId(id) {
            videoToRemoveId = id; // Armazena o ID do Firebase key, que é uma string
            document.getElementById('removeModal').style.display = 'flex';
            document.getElementById('removeAdminName').focus();
        }

        /**
         * Fecha o modal para remover um vídeo e limpa os campos.
         */
        function closeRemoveModal() {
            document.getElementById('removeModal').style.display = 'none';
            document.getElementById('removeAdminName').value = '';
            document.getElementById('removePassword').value = '';
            videoToRemoveId = null; // Reseta o ID do vídeo a ser removido
        }

        /**
          * Lógica central para limpar a fila (sem autenticação).
          * Remove todos os vídeos da fila.
          * @returns {Promise<boolean>} - Retorna 'true' se foi bem-sucedido, 'false' se falhou.
          */
        async function executeClearQueue() {
            try {
                await videoQueueRef.remove();
                showNotification('Fila limpa com sucesso!', 'success');
                return true;
            } catch (error) {
                console.error('Erro ao limpar fila:', error);
                showNotification('Erro ao limpar a fila. Verifique a conexão.', 'error');
                return false;
            }
        }

        /**
         * Limpa toda a fila de vídeos no Firebase Realtime Database.
         * Requer credenciais de administrador (chamado pelo modal).
         */
        async function clearQueue() {
            const adminEmail = document.getElementById('adminName').value.trim();
            const password = document.getElementById('clearPassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha todos os campos.', 'error');
                return;
            }

            toggleLoading('clearQueueBtn', true);

            try {
                // 1. Tenta autenticar
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);

                // 2. Se autenticou, executa a lógica de limpar
                const success = await executeClearQueue();

                // 3. Se foi bem-sucedido, fecha o modal
                if (success) {
                    closeModal();
                }

            } catch (error) {
                console.error('Erro de autenticação ou ao limpar fila:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    showNotification('Erro ao limpar a fila. Verifique a conexão.', 'error');
                }
            } finally {
                toggleLoading('clearQueueBtn', false);
            }
        }

        /**
         * Remove um vídeo específico da fila no Firebase Realtime Database.
         * Requer credenciais de administrador.
         */
        async function removeVideo() {
            const adminEmail = document.getElementById('removeAdminName').value.trim();
            const password = document.getElementById('removePassword').value;

            if (!adminEmail || !password) {
                showNotification('Por favor, preencha todos os campos.', 'error');
                return;
            }

            if (videoToRemoveId === null) {
                showNotification('Nenhum vídeo selecionado para remoção.', 'error');
                return;
            }

            toggleLoading('removeVideoBtn', true);

            try {
                await firebase.auth().signInWithEmailAndPassword(adminEmail, password);
                await videoQueueRef.child(videoToRemoveId).remove();
                showNotification('Vídeo removido com sucesso!', 'success');
                closeRemoveModal();
            } catch (error) {
                console.error('Erro de autenticação ou ao remover vídeo:', error);
                if (error.code === 'auth/wrong-password') {
                    showNotification('Senha incorreta. Por favor, tente novamente.', 'error');
                } else if (error.code === 'auth/user-not-found' || error.code === 'auth/invalid-email') {
                    showNotification('E-mail não encontrado ou inválido. Tente novamente.', 'error');
                } else {
                    showNotification('Erro ao remover o vídeo. Verifique a conexão.', 'error');
                }
            } finally {
                toggleLoading('removeVideoBtn', false);
            }
        }

        // Event listeners para alternar a visibilidade da senha nos modais
        document.getElementById('togglePassword').addEventListener('click', function () {
            const passwordField = document.getElementById('clearPassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        document.getElementById('toggleRemovePassword').addEventListener('click', function () {
            const passwordField = document.getElementById('removePassword');
            const type = passwordField.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordField.setAttribute('type', type);
            this.innerHTML = type === 'password' ? '<i class="fas fa-eye"></i>' : '<i class="fas fa-eye-slash"></i>';
        });

        // Fecha os modais se o usuário clicar fora do conteúdo do modal
        window.addEventListener('click', function (event) {
            if (event.target.classList.contains('modal')) {
                closeModal();
                closeRemoveModal();
                closeYTSearchModal();
                closeNextVideoModal();
                closeAdminUnlockModal();
                closeBulkRemoveConfirmModal();
                closePanelModal();
                closeDeleteAllRoomsModal();
            }
        });

        // Fecha os modais se o usuário pressionar a tecla 'Escape'
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                closeModal();
                closeRemoveModal();
                closeYTSearchModal();
                closeNextVideoModal();
                closeAdminUnlockModal();
                closeBulkRemoveConfirmModal();
                closePanelModal();
                closeDeleteAllRoomsModal();
            }
        });

        // ====================================================================
        // Funções do Chat (Integradas)
        // ====================================================================

        /**
         * Inicializa os listeners do chat.
         */
        function initializeChatFunctions() {
            loadChatMessages();
            setupTypingListeners();
        }

        /**
         * Carrega as mensagens do chat e ouve por novas.
         */
        function loadChatMessages() {
            chatMessagesRef.orderByChild('timestamp').limitToLast(50).on('value', (snapshot) => {
                const messages = snapshot.val() || {};
                displayMessages(messages);
            });
        }

        /**
         * Configura os listeners de "digitando".
         */
        function setupTypingListeners() {
            chatTypingRef.on('value', (snapshot) => {
                const typingUsers = snapshot.val() || {};
                updateTypingIndicator(typingUsers);
            });
        }

        /**
         * Envia a mensagem do chat para o Firebase.
         */
        function sendChatMessage() {
            const messageInput = document.getElementById('chatMessageInput');
            const messageText = messageInput.value.trim();

            if (messageText === '') return;

            // Pega o nome do usuário da sessão (do index.html)
            const userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

            // Para o indicador de "digitando"
            stopTyping();

            // --- MODIFICAÇÃO AQUI ---
            // Cria a mensagem base
            const messageData = {
                userId: userVoteId, // Reutiliza o ID único do sistema de votação
                userName: userName,
                userIsAdmin: isAdminLoggedIn, // Reutiliza a variável global de admin
                text: messageText,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            // Adiciona dados de resposta, se houver
            if (currentReplyMessage) {
                messageData.replyToId = currentReplyMessage.id;
                messageData.replyToUser = currentReplyMessage.user;
                messageData.replyToText = currentReplyMessage.text;
            }

            // Salva no Firebase
            chatMessagesRef.push(messageData)
                .then(() => {
                    messageInput.value = ''; // Limpa o campo
                    cancelReply(); // <-- LIMPA O CONTEXTO DE RESPOSTA
                })
                .catch((error) => {
                    console.error('Erro ao enviar mensagem:', error);
                    showNotification('Erro ao enviar mensagem', 'error');
                });
        }

        /**
         * Lida com a tecla Enter no input do chat.
         */
        function handleChatInput(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            } else {
                startTyping(); // Inicia indicador de digitação
            }
        }

        /**
         * Informa ao Firebase que o usuário está digitando.
         */
        function startTyping() {
            const userName = sessionStorage.getItem('ytSessionUser') || 'Visitante';

            if (!isTyping) {
                isTyping = true;
                chatTypingRef.child(userVoteId).set({
                    name: userName,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // Reinicia o timeout
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(stopTyping, 3000);
        }

        /**
         * Informa ao Firebase que o usuário parou de digitar.
         */
        function stopTyping() {
            if (isTyping) {
                isTyping = false;
                chatTypingRef.child(userVoteId).remove();
            }
            clearTimeout(typingTimeout);
        }

        /**
         * Mostra quem está digitando.
         */
        function updateTypingIndicator(typingUsers) {
            const typingIndicator = document.getElementById('typingIndicator');
            const typingUserSpan = document.getElementById('typingUser');

            const now = Date.now();
            const activeTypers = Object.entries(typingUsers)
                .filter(([userId, data]) => {
                    if (userId === userVoteId) return false; // Não mostrar a si mesmo
                    return (now - (data.timestamp || 0)) < 3000;
                })
                .map(([_, data]) => data.name);

            if (activeTypers.length > 0) {
                typingUserSpan.textContent = activeTypers.join(', ');
                typingIndicator.classList.add('active');
            } else {
                typingIndicator.classList.remove('active');
            }
        }

        /**
         * Renderiza as mensagens na tela.
         */
        function displayMessages(messages) {
            const chatContainer = document.getElementById('chatMessages');
            const emptyChat = chatContainer.querySelector('.empty-chat');

            if (Object.keys(messages).length > 0 && emptyChat) {
                emptyChat.remove();
            }

            const typingIndicator = document.getElementById('typingIndicator');
            chatContainer.innerHTML = ''; // Limpa o chat
            if (typingIndicator) {
                chatContainer.appendChild(typingIndicator); // Readiciona o indicador
            }

            // --- MODIFICAÇÃO AQUI ---
            // Itera sobre as CHAVES (keys) do objeto, não só os valores
            // O "orderByChild" do Firebase já garante a ordem
            Object.keys(messages).forEach(key => {
                const message = messages[key];
                // Passa a CHAVE (ID) e o objeto da mensagem
                const messageElement = createMessageElement(key, message);
                chatContainer.appendChild(messageElement);
            });

            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function getUserColor(str) {
            if (!str || str === 'Visitante') return 'hsl(0, 0%, 70%)'; // Cor padrão para 'Visitante'

            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = hash % 360; // 0 a 360
            const saturation = 70; // Fixo: 70% (bom e colorido)
            const lightness = 65;  // Fixo: 65% (claro, bom em fundo escuro)

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        /**
     * Cria o elemento HTML para uma única mensagem (ESTILO BOLHA). (MODIFICADA)
     * @param {string} messageKey - O ID (chave) da mensagem no Firebase.
     * @param {object} message - O objeto da mensagem.
     */
        function createMessageElement(messageKey, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message';
            messageElement.id = 'msg-' + messageKey; // ID para o scroll

            // Verifica se é "minha"
            const isMine = (message.userId === userVoteId);
            if (isMine) {
                messageElement.classList.add('mine');
            }

            if (message.userIsAdmin) {
                messageElement.classList.add('admin');
            }
            if (message.isSystem) {
                messageElement.classList.add('system');
            }

            // Sanitização
            const safeText = (message.text || '')
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
            const safeUser = (message.userName || 'Visitante')
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

            // --- NOVA LÓGICA DE COR ---
            let userColorStyle = ''; // String de estilo
            if (!message.userIsAdmin && !message.isSystem) {
                // Se NÃO for admin e NÃO for sistema, calcula a cor
                const color = getUserColor(message.userName);
                userColorStyle = `style="color: ${color}"`;
            }
            // Se for admin, o CSS (.chat-message.admin .chat-user) vai cuidar disso.
            // --- FIM DA NOVA LÓGICA ---

            // --- 1. Bloco de Resposta (Se esta MENSAGEM é uma resposta) ---
            let replyHtml = '';
            if (message.replyToId) {
                const safeReplyText = (message.replyToText || '')
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
                const safeReplyUser = (message.replyToUser || 'Alguém')
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");

                replyHtml = `
            <div class="chat-reply-block" onclick="scrollToMessage('${message.replyToId}')">
                <div class="chat-reply-block-user">${safeReplyUser}</div>
                <div class="chat-reply-block-text">${safeReplyText}</div>
            </div>
        `;
            }

            // --- 2. Botão de Resposta (Para RESPONDER a esta mensagem) ---
            // Cria um snippet de texto seguro para o onclick
            let snippet = safeText.length > 40 ? safeText.substring(0, 40) + '...' : safeText;
            snippet = snippet.replace(/'/g, "\\'").replace(/"/g, "&quot;").replace(/\n/g, " ");

            const replyBtnHtml = `
        <button class="chat-reply-btn" title="Responder" onclick="setReplyContext('${messageKey}', '${safeUser}', '${snippet}')">
            <i class="fas fa-reply"></i>
        </button>
    `;

            // --- 3. Montagem Final ---
            const timeString = formatTime(message.timestamp);

            messageElement.innerHTML = `
        ${replyHtml} 
        <div class="chat-message-header">
            <div class="chat-user ${message.userIsAdmin ? 'admin-badge' : ''}" ${userColorStyle}>
                ${message.userIsAdmin ? '<i class="fas fa-crown"></i>' : ''}
                ${safeUser}
            </div>
        </div>
        <div class="chat-text">${safeText}</div>
        <div class="chat-time">${timeString}</div>
        ${replyBtnHtml}
    `;

            return messageElement;
        }

        /**
         * Formata o timestamp para exibição.
         */
        function formatTime(timestamp) {
            if (!timestamp) return '';
            const messageTime = new Date(timestamp);
            const now = new Date();

            if (now.toDateString() === messageTime.toDateString()) {
                return messageTime.toLocaleTimeString('pt-BR', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            return messageTime.toLocaleDateString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // ====================================================================
        // Fim das Funções do Chat
        // ====================================================================
        // Efeito de fade-in na carga da página
        document.addEventListener('DOMContentLoaded', function () {
            document.body.style.opacity = '0';
            setTimeout(() => {
                document.body.style.transition = 'opacity 0.5s ease';
                document.body.style.opacity = '1';
            }, 100);
        });

        // Variáveis para o sistema de votação
        let currentSongRef = null;
        let votesRef = null;
        let userVoteId = null;
        // ====================================================================
        // Variáveis do Chat (Integrado)
        // ====================================================================
        const chatMessagesRef = roomRef.child('chat/messages');
        const chatTypingRef = roomRef.child('chat/typing');
        let isTyping = false;
        let typingTimeout;
        let currentReplyMessage = null;
        let onlineUsersCount = 0;

        // Calcula votos necessários baseado em usuários online
        function calculateVotesNeeded() {
            // Se há poucos usuários, precisa da maioria
            if (onlineUsersCount <= 2) return 2;
            if (onlineUsersCount <= 5) return Math.ceil(onlineUsersCount * 0.6); // 60%
            return Math.ceil(onlineUsersCount * 0.5); // 50% para salas maiores
        }

        // Inicializa o chat
        initializeChatFunctions();
        // Inicializa o sistema de votação
        function initializeVotingSystem() {
            currentSongRef = roomRef.child('currentSong');
            votesRef = roomRef.child('currentSong/votes');

            // Gera um ID único para este usuário
            userVoteId = sessionStorage.getItem('userVoteId') || generateUserId();
            sessionStorage.setItem('userVoteId', userVoteId);

            // Monitora número de usuários online
            presenceRef.on('value', (snap) => {
                onlineUsersCount = snap.numChildren();
                updateVotesNeededDisplay();
            });

            // Monitora mudanças na votação
            votesRef.on('value', (snapshot) => {
                updateVoteDisplay(snapshot.val());
            });

            // Reseta votos quando a música muda
            videoQueueRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    const firstVideo = Object.values(data)[0];
                    if (firstVideo) {
                        const videoId = extractVideoId(firstVideo.videoUrl);
                        resetVotesForNewSong(videoId);
                    }
                } else {
                    // Fila vazia - reseta votos
                    resetVotes();
                }
            });
        }

        // Atualiza a exibição dos votos necessários
        function updateVotesNeededDisplay() {
            const votesNeeded = calculateVotesNeeded();
            const votesNeededElement = document.getElementById('votesNeeded');
            if (votesNeededElement) {
                votesNeededElement.textContent = votesNeeded;
            }
        }

        // Atualiza a exibição dos votos no botão
        function updateVoteDisplay(votes) {
            const voteCountElement = document.getElementById('voteCount');
            const votesNeededElement = document.getElementById('votesNeeded');
            const skipVoteBtn = document.getElementById('skipVoteBtn');
            const skipVoteBtnText = document.getElementById('skipVoteBtnText');

            if (!votes) {
                voteCountElement.textContent = '0';
                updateVotesNeededDisplay();
                skipVoteBtnText.textContent = 'Votar para Pular';
                skipVoteBtn.disabled = false;
                skipVoteBtn.classList.remove('voted');
                return;
            }

            const voteCount = Object.keys(votes).length;
            const votesNeeded = calculateVotesNeeded();

            voteCountElement.textContent = voteCount;
            votesNeededElement.textContent = votesNeeded;

            // Verifica se o usuário atual já votou
            const hasVoted = votes[userVoteId] !== undefined;

            if (hasVoted) {
                skipVoteBtnText.textContent = 'Você Votou';
                skipVoteBtn.disabled = true;
                skipVoteBtn.classList.add('voted');
            } else {
                skipVoteBtnText.textContent = 'Votar para Pular';
                skipVoteBtn.disabled = false;
                skipVoteBtn.classList.remove('voted');
            }

            // Se atingiu o limite de votos, pula a música
            if (voteCount >= votesNeeded) {
                skipSongByVote();
            }
        }

        // Função principal de votação
        function castVoteToSkip() {
            if (!userVoteId) {
                showNotification('Erro: Sistema de votação não inicializado', 'error');
                return;
            }

            // Verifica se há vídeos na fila
            if (videoQueue.length === 0) {
                showNotification('Não há músicas na fila para pular', 'info');
                return;
            }

            // Verifica se há usuários suficientes online
            if (onlineUsersCount < 2) {
                showNotification('Não há usuários suficientes online para votação', 'info');
                return;
            }

            toggleLoading('skipVoteBtn', true);

            // Registra o voto
            votesRef.child(userVoteId).set({
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                userName: currentSessionUser || 'Anônimo',
                userId: userVoteId
            })
                .then(() => {
                    showNotification('Seu voto foi registrado!', 'success');
                })
                .catch((error) => {
                    console.error('Erro ao votar:', error);
                    showNotification('Erro ao registrar voto', 'error');
                })
                .finally(() => {
                    toggleLoading('skipVoteBtn', false);
                });
        }

        // Pula a música quando a votação é bem-sucedida
        function skipSongByVote() {
            if (videoQueue.length === 0) return;

            const votesNeeded = calculateVotesNeeded();
            showNotification(`Votação bem-sucedida! (${votesNeeded}/${votesNeeded} votos) Pulando música...`, 'success');

            // Remove o primeiro vídeo da fila (música atual)
            const firstVideoId = videoQueue[0].id;
            videoQueueRef.child(firstVideoId).remove()
                .then(() => {
                    showNotification('Música pulada por votação popular!', 'success');
                    // Reseta os votos após um delay
                    setTimeout(resetVotes, 1000);
                })
                .catch((error) => {
                    console.error('Erro ao pular música por votação:', error);
                    showNotification('Erro ao pular música', 'error');
                });
        }

        // Reseta os votos para uma nova música
        function resetVotesForNewSong(videoId) {
            if (!currentSongRef) return;

            currentSongRef.set({
                currentVideoId: videoId,
                votes: {},
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                onlineUsersCount: onlineUsersCount
            });
        }

        // Reseta os votos
        function resetVotes() {
            if (votesRef) {
                votesRef.set({});
            }
        }

        // Gera ID único para usuário
        function generateUserId() {
            return 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }

        // Inicializa o sistema de votação quando o DOM estiver pronto
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(initializeVotingSystem, 1000);
        });

        function FuncaoParaAbrirPainel() {
            // 1. Carrega os dados das salas do Firebase
            loadAdminPanelRooms();
            // 2. Abre o modal
            document.getElementById('panelModal').style.display = 'flex';
        }

        /**
         * Fecha o modal do Painel de Controle Admin.
         */
        function closePanelModal() {
            document.getElementById('panelModal').style.display = 'none';
        }
        // ====================================================================
        // Funções de Resposta do Chat (NOVAS)
        // ====================================================================

        /**
         * Prepara o contexto de resposta
         * (messageKey é o ID do firebase)
         * (userName é o nome do autor original)
         * (messageText é o texto original)
         */
        function setReplyContext(messageKey, userName, messageText) {
            currentReplyMessage = {
                id: messageKey,
                user: userName,
                text: messageText
            };

            // Pega a barra de ações principal
            const actionsBar = document.getElementById('chatActionsBar');
            const contextBox = document.getElementById('chatReplyContext');

            contextBox.querySelector('.chat-reply-user').textContent = `Respondendo a ${userName}`;
            contextBox.querySelector('.chat-reply-text').textContent = messageText;

            // Mostra AMBOS (o contêiner e o conteúdo)
            contextBox.style.display = 'flex';
            actionsBar.style.display = 'block'; // <-- ESTA LINHA É NOVA

            document.getElementById('chatMessageInput').focus();
        }

        /**
         * Cancela a resposta
         */
        function cancelReply() {
            currentReplyMessage = null;

            // Pega a barra de ações principal
            const actionsBar = document.getElementById('chatActionsBar');
            const contextBox = document.getElementById('chatReplyContext');

            // Esconde AMBOS
            contextBox.style.display = 'none';
            actionsBar.style.display = 'none'; // <-- ESTA LINHA É NOVA
        }

        /**
         * Rola a tela até a mensagem original
         */
        function scrollToMessage(messageKey) {
            const element = document.getElementById('msg-' + messageKey);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Adiciona um destaque temporário
                element.classList.remove('message-highlighted'); // Remove
                void element.offsetWidth; // "Reflow" para forçar a animação
                element.classList.add('message-highlighted'); // Adiciona
            } else {
                showNotification('Mensagem original não encontrada (pode estar muito antiga)', 'info');
            }
        }

        /**
         * Limpa TODO o histórico do chat. (Função de Admin)
         */
        async function handleClearChat() {
            // Dupla verificação de segurança
            if (!isAdminLoggedIn) {
                showNotification('Apenas administradores podem limpar o chat.', 'error');
                return;
            }

            // Confirmação final
            if (!confirm('Tem certeza que deseja apagar TODO o histórico do chat para TODOS os usuários? Esta ação não pode ser desfeita.')) {
                return;
            }

            console.log('Admin limpando o chat...');
            try {
                // 1. Remove todas as mensagens do Firebase
                await chatMessagesRef.remove();

                // 2. (Opcional) Adiciona uma mensagem de "Chat limpo"
                await chatMessagesRef.push({
                    userId: 'system',
                    userName: 'Sistema',
                    text: 'O histórico do chat foi limpo por um administrador.',
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    isSystem: true // Marca como mensagem de sistema
                });

                showNotification('Histórico do chat foi limpo com sucesso!', 'success');

            } catch (error) {
                console.error('Erro ao limpar o chat:', error);
                showNotification('Erro ao limpar o chat. Verifique as regras do Firebase.', 'error');
            }
        }

        /**
 * Carrega as salas ativas no painel de admin.
 */
        async function loadAdminPanelRooms() {
            const listElement = document.getElementById('adminRoomList');
            const loaderElement = document.getElementById('adminRoomLoader');

            if (!listElement || !loaderElement) {
                console.error('Elementos do painel admin não encontrados.');
                return;
            }

            listElement.innerHTML = ''; // Limpa a lista antiga
            loaderElement.style.display = 'block'; // Mostra o loader

            try {
                // 1. Referência para o nó principal 'rooms'
                const roomsRef = database.ref('rooms');

                // 2. Busca os dados UMA VEZ
                const snapshot = await roomsRef.once('value');
                const roomsData = snapshot.val();

                if (!roomsData) {
                    // Se não houver salas, mostra mensagem
                    loaderElement.innerHTML = '<div class="empty-yt"><i class="fas fa-ghost"></i><p>Nenhuma sala ativa encontrada.</p></div>';
                    return;
                }

                const roomIds = Object.keys(roomsData);
                let htmlToRender = '';

                // 3. Itera por cada sala encontrada
                roomIds.forEach(roomId => {
                    const room = roomsData[roomId];

                    // *** IMPORTANTE: Estou assumindo que você salva 'name' e 'createdAt' dentro de cada sala ***
                    // Se você não salvar, 'room.name' será nulo e 'room.createdAt' também.
                    const roomName = room.roomName || 'Sala sem nome'; // Ex: "VIP"

                    // Tenta formatar a data, se existir
                    let createdAt = 'Data desconhecida';
                    if (room.createdAt) {
                        try {
                            createdAt = new Date(room.createdAt).toLocaleString('pt-BR');
                        } catch (e) {
                            createdAt = 'Invalid Date'; // Igual ao da sua imagem
                        }
                    }

                    // 4. Cria o HTML para o item
                    htmlToRender += `
                <div class="admin-room-item" data-room-id="${roomId}">
                    <div class="room-info">
                        <strong>${roomName}</strong>
                        <span>Criada em: ${createdAt}</span>
                        <span>ID: ${roomId}</span>
                    </div>
                    <div class="room-actions">
                        <button class="btn small secondary" onclick="goToRoom('${roomId}')" title="Abrir sala em nova aba">
                            <i class="fas fa-eye"></i> Ver
                        </button>
                        <button class="btn small danger" onclick="deleteRoom('${roomId}')" title="Deletar sala">
                            <i class="fas fa-trash"></i> Deletar
                        </button>
                    </div>
                </div>
            `;
                });

                listElement.innerHTML = htmlToRender;
                loaderElement.style.display = 'none'; // Esconde o loader

            } catch (error) {
                console.error('Erro ao carregar salas:', error);
                loaderElement.innerHTML = '<div class="error-yt"><i class="fas fa-exclamation-triangle"></i><p>Erro ao carregar salas.</p></div>';
            }
        }

        /**
         * (Função Auxiliar) Redireciona o admin para a sala selecionada.
         */
        function goToRoom(roomId) {
            if (!roomId) return;
            // Abre a sala (index.html) em uma nova aba com o ID da sala
            window.open(`index.html?room=${roomId}`, '_blank');
        }

        /**
         * (Função Auxiliar) Deleta uma sala do Firebase.
         */
        async function deleteRoom(roomId) {
            if (!roomId) return;

            // Pega o nome da sala pelo HMTL para a confirmação
            const roomElement = document.querySelector(`.admin-room-item[data-room-id="${roomId}"]`);
            const roomName = roomElement ? roomElement.querySelector('strong').textContent : 'Sala';

            if (confirm(`Tem certeza que deseja deletar a sala "${roomName}"? \n\nID: ${roomId}\n\nISSO É IRREVERSÍVEL E VAI APAGAR TODA A FILA E CHAT DELA.`)) {
                try {
                    // Remove a sala inteira do Firebase
                    await database.ref(`rooms/${roomId}`).remove();

                    showNotification(`Sala "${roomName}" deletada com sucesso.`, 'success');

                    // Remove o item da lista na tela
                    if (roomElement) {
                        roomElement.style.transition = 'all 0.3s ease';
                        roomElement.style.opacity = '0';
                        roomElement.style.transform = 'translateX(-20px)';
                        setTimeout(() => roomElement.remove(), 300);
                    }

                } catch (error) {
                    console.error('Erro ao deletar sala:', error);
                    showNotification('Erro ao deletar sala.', 'error');
                }
            }
        }
        /**
                 * Abre o modal de confirmação para deletar TODAS as salas.
                 */
        function openDeleteAllRoomsModal() {
            document.getElementById('deleteAllRoomsModal').style.display = 'flex';
        }

        /**
         * Fecha o modal de confirmação para deletar TODAS as salas.
         */
        function closeDeleteAllRoomsModal() {
            document.getElementById('deleteAllRoomsModal').style.display = 'none';
        }

        /**
         * Executa a remoção de TODAS as salas do Firebase.
         */
        async function executeDeleteAllRooms() {
            toggleLoading('deleteAllRoomsConfirmBtn', true);

            try {
                // Pega a referência principal 'rooms'
                const roomsRef = database.ref('rooms');

                // Remove TUDO de 'rooms'
                await roomsRef.remove();

                showNotification('Todas as salas foram deletadas com sucesso.', 'success');

                // Atualiza a lista no modal (que agora estará vazia)
                loadAdminPanelRooms(); //

            } catch (error) {
                console.error('Erro ao deletar todas as salas:', error);
                showNotification('Erro ao deletar salas.', 'error');
            } finally {
                toggleLoading('deleteAllRoomsConfirmBtn', false);
                closeDeleteAllRoomsModal();
            }
        }

    </script>
    </div>
</body>

</html>